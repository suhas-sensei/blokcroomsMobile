Project Path: src

Source Tree:

```
src
‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îî‚îÄ‚îÄ device.js
‚îú‚îÄ‚îÄ Model.jsx
‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îî‚îÄ‚îÄ supabase.js
‚îú‚îÄ‚îÄ App.jsx
‚îú‚îÄ‚îÄ components
‚îÇ   ‚îú‚îÄ‚îÄ game
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BulletHole.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Instructions.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Gun.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Entity.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AudioManager.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FirstPersonControls.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BloodEffect.jsx
‚îÇ   ‚îú‚îÄ‚îÄ mobile
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MobileShootButton.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VirtualJoystick.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MobileTouchControls.jsx
‚îÇ   ‚îî‚îÄ‚îÄ ui
‚îÇ       ‚îú‚îÄ‚îÄ Join.jsx
‚îÇ       ‚îú‚îÄ‚îÄ WarningDialog.jsx
‚îÇ       ‚îî‚îÄ‚îÄ DeathScreen.jsx
‚îú‚îÄ‚îÄ index.jsx
‚îú‚îÄ‚îÄ Gun1.jsx
‚îî‚îÄ‚îÄ styles.css

```

`/home/suhas/Desktop/waitlist/src/utils/device.js`:

```js
export const isMobile = () => {
  // First check for touch capability
  const hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;

  // Then check user agent
  const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  // Check screen size
  const isSmallScreen = window.innerWidth <= 768;

  // Force mobile if any condition is true
  return hasTouch || isMobileUA || isSmallScreen;
};

```

`/home/suhas/Desktop/waitlist/src/Model.jsx`:

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model.glb 
Author: Huuxloc (https://sketchfab.com/rjh41)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/original-backrooms-e5c6b30995ff442d9852a1dd697aaef1
Title: Original Backrooms
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

export function Model(props) {
  const { nodes, materials } = useGLTF('/model.glb')
  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={1.25}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1.416, -2.739]} rotation={[0, -Math.PI / 2, 0]}>
            <mesh geometry={nodes.Object_8.geometry} material={materials.PlugSocket} />
            <mesh geometry={nodes.Object_9.geometry} material={materials.GreenSkirting} />
            <mesh geometry={nodes.Object_10.geometry} material={materials.BR_2} />
            <mesh geometry={nodes.Object_11.geometry} material={materials.StripeWallpaper} />
            <mesh geometry={nodes.Object_12.geometry} material={materials.Dot_Wallpaper} />
          </group>
          <group position={[-3.842, 2.143, 1.4]}>
            <mesh geometry={nodes.Object_16.geometry} material={materials.Ceiling_Grid} />
            <mesh geometry={nodes.Object_17.geometry} material={materials.Ceiling_Lights} />
          </group>
          <mesh geometry={nodes.Object_4.geometry} material={materials.Vent} position={[-2.246, 2.15, -1.332]} />
          <mesh geometry={nodes.Object_6.geometry} material={materials.Piece1} position={[-5.461, 1.416, 5.699]} rotation={[-Math.PI, 0, -Math.PI]} />
          <mesh geometry={nodes.Object_14.geometry} material={materials.NewCarpet} position={[0.016, 0.006, -5.539]} />
          <mesh geometry={nodes.Object_19.geometry} material={materials.CeilingTile} position={[-3.842, 2.143, 1.4]} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/model.glb')

```

`/home/suhas/Desktop/waitlist/src/lib/supabase.js`:

```js
// import { createClient } from "@supabase/supabase-js";

// const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
// const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

// export const supabase = createClient(supabaseUrl, supabaseKey);

```

`/home/suhas/Desktop/waitlist/src/App.jsx`:

```jsx
import React, { useRef, useState } from "react";
import { Canvas } from "@react-three/fiber";
import { PointerLockControls } from "@react-three/drei";
import { Vector3 } from "three";
import { Model } from "../src/Model";
import { Model as GunModel } from "../src/Gun1";

// Utility imports
import { isMobile } from "../src/utils/device";

// UI components
import WarningDialog from "../src/components/ui/WarningDialog";
import DeathScreen from "../src/components/ui/DeathScreen";
import Join from "../src/components/ui/Join";

// Mobile components
import VirtualJoystick from "../src/components/mobile/VirtualJoystick";
import MobileTouchControls from "../src/components/mobile/MobileTouchControls";
import MobileShootButton from "../src/components/mobile/MobileShootButton";

// Game components
import Gun from "../src/components/game/Gun";
import Entity from "../src/components/game/Entity";
import BloodEffect from "../src/components/game/BloodEffect";
import BulletHole from "../src/components/game/BulletHole";
import AudioManager from "../src/components/game/AudioManager";
import FirstPersonControls from "../src/components/game/FirstPersonControls";
import Instructions from "../src/components/game/Instructions";

const App = () => {
  const [playerPosition, setPlayerPosition] = useState(new Vector3(0, 1.6, 0));
  const [entityDistance, setEntityDistance] = useState(null);
  const [gameOver, setGameOver] = useState(false);
  const [showGun, setShowGun] = useState(true);
  const [bloodEffects, setBloodEffects] = useState([]);
  const [bulletHoles, setBulletHoles] = useState([]);
  const [showJoinPage, setShowJoinPage] = useState(false);
  const [showWarning, setShowWarning] = useState(true);
  const [gameStarted, setGameStarted] = useState(false);
  const [mobileMovement, setMobileMovement] = useState({ x: 0, y: 0 });

  const entityRef = useRef();
  const shootFunctionRef = useRef(null);
  const mobile = isMobile();

  const handleEntityCatch = () => {
    setGameOver(true);
  };

  const handleDistanceUpdate = distance => {
    setEntityDistance(distance);
  };

  const handlePositionUpdate = position => {
    setPlayerPosition(position);
  };

  const handleAudioStop = () => {
    console.log("All audio stopped, player is dead");
  };

  const handleJoin = () => {
    console.log("Redirecting to join page");
    setShowJoinPage(true);
  };

  const handleWarningAccept = () => {
    setShowWarning(false);
    setGameStarted(true);
  };

  const handleJoystickMove = movement => {
    setMobileMovement(movement);
  };

  const handleMobileShoot = () => {
    console.log("üéØ handleMobileShoot called");
    if (shootFunctionRef.current) {
      console.log("‚úÖ Calling shoot function");
      shootFunctionRef.current();
    } else {
      console.log("‚ùå No shoot function reference available");
    }
  };

  if (showJoinPage) {
    return <Join />;
  }

  const handleShoot = (hit, cameraPosition) => {
    if (gameOver) return;

    const hitObject = hit.object;
    const hitPoint = hit.point;
    const hitNormal = hit.face.normal;

    if (hitObject.userData?.isEntity) {
      const bloodId = Date.now() + Math.random();
      setBloodEffects(prev => [
        ...prev,
        {
          id: bloodId,
          position: hitPoint.clone(),
        },
      ]);
    } else {
      const holeId = Date.now() + Math.random();
      const offsetPosition = hitPoint.clone().add(hitNormal.clone().multiplyScalar(0.01));
      setBulletHoles(prev => [
        ...prev,
        {
          id: holeId,
          position: offsetPosition,
          normal: hitNormal.clone(),
          cameraPosition: cameraPosition.clone(),
        },
      ]);
    }
  };

  const handleShootWithRef = {
    shootHandler: (hit, cameraPosition) => {
      handleShoot(hit, cameraPosition);
    },
    setShootFunction: shootFn => {
      shootFunctionRef.current = shootFn;
    },
  };

  const removeBloodEffect = id => {
    setBloodEffects(prev => prev.filter(effect => effect.id !== id));
  };

  const removeBulletHole = id => {
    setBulletHoles(prev => prev.filter(hole => hole.id !== id));
  };

  return (
    <div style={{ width: "100vw", height: "100vh", position: "relative" }}>
      {showWarning && <WarningDialog onAccept={handleWarningAccept} />}
      <AudioManager entityDistance={entityDistance} gameOver={gameOver} onAudioStop={handleAudioStop} />
      {gameOver && <DeathScreen onJoin={handleJoin} />}

      {mobile && gameStarted && !gameOver && !showWarning && (
        <>
          <VirtualJoystick onJoystickMove={handleJoystickMove} isVisible={true} />
          <MobileShootButton onShoot={handleMobileShoot} isVisible={true} />
        </>
      )}

      <Instructions gameOver={gameOver} />

      <Canvas
        camera={{
          fov: 75,
          position: [0, 1.6, 0],
          rotation: [0, 0, 0],
          near: 0.1,
          far: 1000,
        }}
        onCreated={({ camera }) => {
          camera.rotation.set(0, 0, 0);
          camera.lookAt(0, 1.6, -1);
        }}
      >
        <ambientLight intensity={0.4} color='#fff8dc' />
        <directionalLight position={[5, 5, 5]} intensity={0.6} color='#fff8dc' castShadow />
        <directionalLight position={[-5, 3, -5]} intensity={0.3} color='#f4e4bc' />

        {!mobile && <PointerLockControls />}
        {mobile && <MobileTouchControls gameOver={gameOver} />}

        <FirstPersonControls onPositionUpdate={handlePositionUpdate} gameOver={gameOver} mobileMovement={mobileMovement} />
        <Model />
        <Gun isVisible={showGun} onShoot={handleShootWithRef} />

        {bloodEffects.map(effect => (
          <BloodEffect key={effect.id} position={effect.position} onComplete={() => removeBloodEffect(effect.id)} />
        ))}

        {bulletHoles.map(hole => (
          <BulletHole
            key={hole.id}
            position={hole.position}
            normal={hole.normal}
            cameraPosition={hole.cameraPosition}
            onComplete={() => removeBulletHole(hole.id)}
          />
        ))}
      </Canvas>
    </div>
  );
};

export default App;

```

`/home/suhas/Desktop/waitlist/src/components/game/BulletHole.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import * as THREE from "three";

function BulletHole({ position, normal, cameraPosition, onComplete }) {
  const holeRef = useRef();

  useEffect(() => {
    // Load hole texture
    const textureLoader = new THREE.TextureLoader();
    const holeTexture = textureLoader.load("/hole.png");

    if (holeRef.current) {
      holeRef.current.material.map = holeTexture;
      holeRef.current.material.transparent = true;
      holeRef.current.material.needsUpdate = true;

      // Orient the hole to face towards the camera (player)
      holeRef.current.lookAt(cameraPosition);
    }

    // Remove bullet hole after 10 seconds
    const removeTimeout = setTimeout(() => {
      if (onComplete) onComplete();
    }, 10000);

    return () => clearTimeout(removeTimeout);
  }, [position, normal, cameraPosition, onComplete]);

  return (
    <mesh ref={holeRef} position={position}>
      <planeGeometry args={[0.15, 0.15]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default BulletHole;

```

`/home/suhas/Desktop/waitlist/src/components/game/Instructions.jsx`:

```jsx
import React from "react";
import { isMobile } from "../../utils/device";

function Instructions({ gameOver }) {
  if (gameOver) return null; // Hide instructions when game is over

  const mobile = isMobile();

  // You can add instruction rendering logic here if needed
  // For now, returning null as the original component was empty
  return null;
}

export default Instructions;

```

`/home/suhas/Desktop/waitlist/src/components/game/Gun.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Vector3, Raycaster } from "three";
import * as THREE from "three";
import { Model as GunModel } from "../../Gun1"; // Import the gun model
import { isMobile } from "../../utils/device";

function Gun({ isVisible = true, onShoot }) {
  const gunRef = useRef();
  const { camera, scene } = useThree();

  // Timer to drive breathing motion
  const swayTime = useRef(0);

  // Visual recoil state (doesn't block shooting)
  const [visualRecoil, setVisualRecoil] = useState(false);
  const recoilTime = useRef(0);
  const shootSound = useRef(null);

  // Load and apply textures
  useEffect(() => {
    // Load shoot sound
    const audio = new Audio("/shot.mp3");
    audio.volume = 0.7;
    shootSound.current = audio;

    if (gunRef.current) {
      const textureLoader = new THREE.TextureLoader();

      // Load beretta (gun) textures
      const berettaColor = textureLoader.load("/textures/berettaColor.png");
      const berettaNormal = textureLoader.load("/textures/berettaNormal.png");
      const berettaMetallic = textureLoader.load("/textures/berettaMetallic.png");
      const berettaRoughness = textureLoader.load("/textures/berettaRoughness.png");
      const berettaAO = textureLoader.load("/textures/berettaAO.png");

      // Load arms textures
      const armsColor = textureLoader.load("/textures/armsColor.png");
      const armsNormal = textureLoader.load("/textures/armsNormal.png");
      const armsRoughness = textureLoader.load("/textures/armsRoughness.png");
      const armsAO = textureLoader.load("/textures/armsAO.png");

      // Apply textures to materials
      gunRef.current.traverse(child => {
        if (child.isMesh && child.material) {
          const material = child.material;

          if (material.name === "beretta") {
            material.map = berettaColor;
            material.normalMap = berettaNormal;
            material.metalnessMap = berettaMetallic;
            material.roughnessMap = berettaRoughness;
            material.aoMap = berettaAO;
            material.metalness = 1.0;
            material.roughness = 0.4;
            material.aoMapIntensity = 1.0;
            child.castShadow = true;
            child.receiveShadow = true;
            material.needsUpdate = true;
          }

          if (material.name === "arms") {
            material.map = armsColor;
            material.normalMap = armsNormal;
            material.roughnessMap = armsRoughness;
            material.aoMap = armsAO;
            material.metalness = 0.0;
            material.roughness = 0.8;
            material.aoMapIntensity = 1.0;
            child.castShadow = true;
            child.receiveShadow = true;
            material.needsUpdate = true;
          }
        }
      });
    }

    // Add mouse click event listener for shooting (only for non-mobile)
    const handleMouseClick = event => {
      if (event.button === 0 && isVisible && !isMobile()) {
        shoot();
      }
    };

    if (!isMobile()) {
      document.addEventListener("mousedown", handleMouseClick);
    }

    return () => {
      if (!isMobile()) {
        document.removeEventListener("mousedown", handleMouseClick);
      }
      if (shootSound.current) {
        shootSound.current = null;
      }
    };
  }, [isVisible]);

  // FIXED: Shoot function with NO blocking - can always shoot
  const shoot = () => {
    console.log("üî´ SHOOTING - No blocks, always fires!");

    // Play shoot sound (create new audio instance each time for rapid fire)
    if (shootSound.current) {
      try {
        // Clone the audio for rapid fire
        const shotAudio = shootSound.current.cloneNode();
        shotAudio.volume = 0.7;
        shotAudio.currentTime = 0;
        shotAudio.play().catch(error => {
          console.log("Failed to play shoot sound:", error);
        });
      } catch (error) {
        console.log("Audio clone failed, using original:", error);
        shootSound.current.currentTime = 0;
        shootSound.current.play().catch(err => {
          console.log("Original audio failed too:", err);
        });
      }
    }

    // Perform raycast from camera center
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(camera.quaternion);

    raycaster.set(camera.position, direction);
    const intersects = raycaster.intersectObjects(scene.children, true);

    // Filter out gun and non-solid objects
    const validIntersects = intersects.filter(intersect => {
      const object = intersect.object;
      return (
        !object.isLight &&
        !object.isCamera &&
        !gunRef.current?.children.some(child => child === object || child.children.includes(object)) &&
        (object.userData?.isEntity || (object.geometry && object.material)) &&
        object.visible
      );
    });

    if (validIntersects.length > 0 && onShoot?.shootHandler) {
      const hit = validIntersects[0];
      console.log("üéØ HIT DETECTED:", hit.object);
      onShoot.shootHandler(hit, camera.position);
    }

    // Start VISUAL recoil animation (doesn't block shooting)
    setVisualRecoil(true);
    recoilTime.current = 0;

    // End visual recoil quickly
    setTimeout(() => {
      setVisualRecoil(false);
    }, 80); // Very short visual recoil
  };

  // Expose shoot function to parent component
  useEffect(() => {
    if (onShoot && onShoot.setShootFunction) {
      console.log("üîó Setting shoot function reference");
      onShoot.setShootFunction(shoot);
    }
  }, [onShoot]);

  useFrame((_, delta) => {
    if (!gunRef.current || !isVisible) return;

    // Increment sway timer
    swayTime.current += delta;

    // Breathing sway amount
    const swayY = Math.sin(swayTime.current * 2) * 0.01;

    // Base position from camera
    const gunPosition = new THREE.Vector3();
    camera.getWorldPosition(gunPosition);

    const forward = new THREE.Vector3(0, 0, -1);
    const right = new THREE.Vector3(1, 0, 0);
    const down = new THREE.Vector3(0, -1, 0);

    forward.applyQuaternion(camera.quaternion);
    right.applyQuaternion(camera.quaternion);
    down.applyQuaternion(camera.quaternion);

    gunPosition.add(forward.multiplyScalar(0.5));
    gunPosition.add(right.multiplyScalar(0.3));
    gunPosition.add(down.multiplyScalar(0.2 + swayY));

    // Handle VISUAL recoil animation (doesn't affect shooting)
    let recoilOffset = new THREE.Vector3();
    let recoilRotation = { x: 0, y: 0, z: 0 };

    if (visualRecoil) {
      recoilTime.current += delta;
      const recoilDuration = 0.08; // Very quick visual recoil
      const recoilProgress = Math.min(recoilTime.current / recoilDuration, 1);
      const easedProgress = 1 - Math.pow(1 - recoilProgress, 3);

      const maxBackwardRecoil = 0.1;
      const maxUpwardRecoil = 0.05;
      const maxRotationRecoil = -0.2;

      const backwardRecoil = Math.sin(easedProgress * Math.PI) * maxBackwardRecoil;
      const upwardRecoil = Math.sin(easedProgress * Math.PI) * maxUpwardRecoil;
      const rotationRecoil = Math.sin(easedProgress * Math.PI) * maxRotationRecoil;

      recoilOffset.add(forward.clone().multiplyScalar(-backwardRecoil));
      recoilOffset.add(down.clone().multiplyScalar(-upwardRecoil));

      recoilRotation.x = -rotationRecoil;
      recoilRotation.z = (Math.random() - 0.5) * 0.05;
    }

    // Apply final position with recoil
    gunPosition.add(recoilOffset);
    gunRef.current.position.copy(gunPosition);

    // Apply rotation
    gunRef.current.quaternion.copy(camera.quaternion);
    gunRef.current.rotateX(0.1 + recoilRotation.x);
    gunRef.current.rotateY(Math.PI);
    gunRef.current.rotateZ(recoilRotation.z);
  });

  if (!isVisible) return null;

  return (
    <group ref={gunRef}>
      <pointLight position={[0.3, 0.2, 0.4]} intensity={1.5} distance={3} decay={1} color='#ffffff' />
      <pointLight position={[-0.2, -0.1, 0.3]} intensity={1.0} distance={2} decay={2} color='#fff8dc' />
      <GunModel scale={[1, 1, 1]} />
    </group>
  );
}

export default Gun;

```

`/home/suhas/Desktop/waitlist/src/components/game/Entity.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { Vector3 } from "three";
import * as THREE from "three";

function Entity({ playerPosition, onCatch, onDistanceUpdate }) {
  const entityRef = useRef();
  const entitySpeed = 2.5; // Slightly slower than player for tension
  const catchDistance = 1.2; // Distance at which entity catches player

  useEffect(() => {
    // Load entity texture
    const textureLoader = new THREE.TextureLoader();
    const entityTexture = textureLoader.load("/good.png");

    if (entityRef.current) {
      // Apply texture to entity material
      entityRef.current.material.map = entityTexture;
      entityRef.current.material.transparent = true;
      entityRef.current.material.needsUpdate = true;
      // Mark this as an entity for shooting detection
      entityRef.current.userData = { isEntity: true };
    }
  }, []);

  useFrame((state, delta) => {
    if (!entityRef.current || !playerPosition) return;

    const entityPosition = entityRef.current.position;

    // Calculate direction to player
    const direction = new Vector3().subVectors(playerPosition, entityPosition).normalize();

    // Move entity towards player
    const movement = direction.multiplyScalar(entitySpeed * delta);
    entityRef.current.position.add(movement);

    // Make entity always face the player
    entityRef.current.lookAt(playerPosition);

    // Calculate distance to player and update audio
    const distanceToPlayer = entityPosition.distanceTo(playerPosition);
    if (onDistanceUpdate) {
      onDistanceUpdate(distanceToPlayer);
    }

    // Check if entity caught the player
    if (distanceToPlayer < catchDistance) {
      onCatch();
    }
  });

  return (
    <mesh ref={entityRef} position={[10, 1.5, 10]}>
      <planeGeometry args={[3, 2]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default Entity;

```

`/home/suhas/Desktop/waitlist/src/components/game/AudioManager.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";

function AudioManager({ entityDistance, gameOver, onAudioStop }) {
  const audioRef = useRef(null);
  const breathRef = useRef(null);
  const deathSoundRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [hasInteracted, setHasInteracted] = useState(false);

  useEffect(() => {
    // Create background music audio element
    const audio = new Audio("/bgmusic.mp3");
    audio.loop = true;
    audio.volume = 0.001; // Start very quiet
    audioRef.current = audio;

    // Create breathing sound audio element
    const breathAudio = new Audio("/breath.mp3");
    breathAudio.loop = true;
    breathAudio.volume = 0; // Start at 0 for fade in
    breathRef.current = breathAudio;

    // Create death sound audio element
    const deathAudio = new Audio("/ded.mp3");
    deathAudio.volume = 1.0; // Full volume for death sound
    deathSoundRef.current = deathAudio;

    // Try to play background music immediately (will fail without user interaction)
    const tryAutoPlay = async () => {
      try {
        await audio.play();
        setIsPlaying(true);
      } catch (error) {
        console.log("Autoplay blocked, waiting for user interaction");
      }
    };

    tryAutoPlay();

    // Start breathing sound after 3 seconds with fade in
    const breathTimeout = setTimeout(() => {
      const startBreathingSound = async () => {
        try {
          await breathAudio.play();

          // Fade in the breathing sound over 2 seconds
          const fadeInDuration = 2000; // 2 seconds
          const targetVolume = 0.9; // Reduced volume for breathing
          const fadeSteps = 60; // Number of steps for smooth fade
          const stepTime = fadeInDuration / fadeSteps;
          const volumeStep = targetVolume / fadeSteps;

          let currentStep = 0;
          const fadeInterval = setInterval(() => {
            currentStep++;
            const newVolume = Math.min(volumeStep * currentStep, targetVolume);
            breathAudio.volume = newVolume;

            if (currentStep >= fadeSteps) {
              clearInterval(fadeInterval);
            }
          }, stepTime);
        } catch (error) {
          console.log("Failed to play breathing sound:", error);
        }
      };

      startBreathingSound();
    }, 3000); // 3 seconds delay

    // Listen for any user interaction to enable audio
    const handleInteraction = async () => {
      if (!hasInteracted) {
        setHasInteracted(true);
        try {
          await audio.play();
          setIsPlaying(true);
        } catch (error) {
          console.log("Failed to play audio:", error);
        }
      }
    };

    // Add event listeners for user interaction
    document.addEventListener("click", handleInteraction);
    document.addEventListener("keydown", handleInteraction);
    document.addEventListener("touchstart", handleInteraction);

    return () => {
      clearTimeout(breathTimeout);
      document.removeEventListener("click", handleInteraction);
      document.removeEventListener("keydown", handleInteraction);
      document.removeEventListener("touchstart", handleInteraction);
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
      if (breathRef.current) {
        if (breathRef.current.stopTimeout) {
          clearTimeout(breathRef.current.stopTimeout);
        }
        breathRef.current.pause();
        breathRef.current = null;
      }
      if (deathSoundRef.current) {
        if (deathSoundRef.current.timeout) {
          clearTimeout(deathSoundRef.current.timeout);
        }
        if (deathSoundRef.current.breathTimeout) {
          clearTimeout(deathSoundRef.current.breathTimeout);
        }
        if (deathSoundRef.current.allStopTimeout) {
          clearTimeout(deathSoundRef.current.allStopTimeout);
        }
        deathSoundRef.current.pause();
        deathSoundRef.current = null;
      }
    };
  }, [hasInteracted]);

  // Handle game over - stop all audio and play death sound sequence
  useEffect(() => {
    if (gameOver) {
      // Stop all existing audio immediately
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
        setIsPlaying(false);
      }
      if (breathRef.current) {
        breathRef.current.pause();
        breathRef.current.currentTime = 0;
      }

      // Play death sound immediately
      if (deathSoundRef.current) {
        deathSoundRef.current.currentTime = 0;
        deathSoundRef.current.volume = 1.0;

        const playDeathSound = async () => {
          try {
            await deathSoundRef.current.play();
            console.log("Death sound started playing");
          } catch (error) {
            console.log("Failed to play death sound:", error);
          }
        };

        playDeathSound();

        // Stop death sound after 3 seconds
        const deathSoundTimeout = setTimeout(() => {
          if (deathSoundRef.current) {
            deathSoundRef.current.pause();
            deathSoundRef.current.currentTime = 0;
            console.log("Death sound stopped after 3 seconds");
          }
        }, 3000);

        // Start breathing sound after 2 seconds
        const breathStartTimeout = setTimeout(() => {
          if (breathRef.current) {
            breathRef.current.currentTime = 0;
            breathRef.current.volume = 0.9;

            const playBreathSound = async () => {
              try {
                await breathRef.current.play();
                console.log("Breath sound started playing");
              } catch (error) {
                console.log("Failed to play breath sound:", error);
              }
            };

            playBreathSound();
          }
        }, 2000);

        // Stop ALL audio after 6 seconds
        const allAudioStopTimeout = setTimeout(() => {
          console.log("Stopping all audio after 6 seconds");
          if (deathSoundRef.current) {
            deathSoundRef.current.pause();
            deathSoundRef.current.currentTime = 0;
          }
          if (breathRef.current) {
            breathRef.current.pause();
            breathRef.current.currentTime = 0;
          }
          if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0;
          }
          console.log("All audio stopped - ready for join text");
        }, 6000);

        // Store timeouts for cleanup
        deathSoundRef.current.timeout = deathSoundTimeout;
        deathSoundRef.current.breathTimeout = breathStartTimeout;
        deathSoundRef.current.allStopTimeout = allAudioStopTimeout;
      }

      // Notify that audio has stopped
      if (onAudioStop) {
        onAudioStop();
      }
    }
  }, [gameOver, onAudioStop]);

  // Update audio volume based on entity distance (only if not game over)
  useEffect(() => {
    if (!audioRef.current || !isPlaying || gameOver) return;

    // Calculate volume based on entity distance
    // When entity is far (distance > 20), volume is very low (0.05)
    // When entity is close (distance < 5), volume is high (0.8)
    const maxDistance = 8; // Maximum distance for volume calculation
    const minDistance = 2; // Minimum distance for maximum volume
    const minVolume = 0.001; // Minimum volume when entity is far
    const maxVolume = 0.8; // Maximum volume when entity is close

    let volume = minVolume;

    if (entityDistance !== null) {
      if (entityDistance <= minDistance) {
        volume = maxVolume;
      } else if (entityDistance >= maxDistance) {
        volume = minVolume;
      } else {
        // Linear interpolation between min and max volume
        const normalizedDistance = (entityDistance - minDistance) / (maxDistance - minDistance);
        volume = maxVolume - normalizedDistance * (maxVolume - minVolume);
      }
    }

    // Smooth volume transition
    const currentVolume = audioRef.current.volume;
    const volumeDiff = volume - currentVolume;
    const smoothingFactor = 0.1; // Adjust for smoother/faster transitions

    audioRef.current.volume = currentVolume + volumeDiff * smoothingFactor;
  }, [entityDistance, isPlaying, gameOver]);

  // Audio manager runs silently with no UI
  return null;
}

export default AudioManager;

```

`/home/suhas/Desktop/waitlist/src/components/game/FirstPersonControls.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Vector3 } from "three";
import * as THREE from "three";
import { isMobile } from "../../utils/device";

function FirstPersonControls({ onPositionUpdate, gameOver, mobileMovement }) {
  const { camera, scene } = useThree();
  const moveSpeed = 5;
  const playerRadius = 0.3; // Collision radius around player
  const baseHeight = 1.6; // Base camera height (eye level)
  const bobAmplitude = 0.08; // How much the camera bobs up and down
  const bobFrequency = 8; // How fast the bobbing occurs
  const bobTimeRef = useRef(0); // Track time for bobbing animation
  const isMovingRef = useRef(false); // Track if player is moving

  const keys = useRef({
    forward: false,
    backward: false,
    left: false,
    right: false,
  });

  // Handle keyboard input for desktop
  useEffect(() => {
    if (isMobile()) return; // Skip keyboard controls on mobile

    const handleKeyDown = event => {
      if (gameOver) return; // Disable movement when game is over

      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          keys.current.forward = true;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.current.backward = true;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.current.left = true;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.current.right = true;
          break;
      }
    };

    const handleKeyUp = event => {
      if (gameOver) return; // Disable movement when game is over

      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          keys.current.forward = false;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.current.backward = false;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.current.left = false;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.current.right = false;
          break;
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    };
  }, [gameOver]);

  // Handle mobile movement
  useEffect(() => {
    if (!isMobile() || !mobileMovement) return;

    // Convert joystick input to movement keys (more sensitive)
    keys.current.forward = mobileMovement.y > 0.1;
    keys.current.backward = mobileMovement.y < -0.1;
    keys.current.left = mobileMovement.x < -0.1;
    keys.current.right = mobileMovement.x > 0.1;
  }, [mobileMovement]);

  // Check for collisions using raycasting
  const checkCollision = newPosition => {
    const raycaster = new THREE.Raycaster();
    const directions = [
      new Vector3(1, 0, 0), // right
      new Vector3(-1, 0, 0), // left
      new Vector3(0, 0, 1), // forward
      new Vector3(0, 0, -1), // backward
      new Vector3(0.707, 0, 0.707), // diagonal
      new Vector3(-0.707, 0, 0.707), // diagonal
      new Vector3(0.707, 0, -0.707), // diagonal
      new Vector3(-0.707, 0, -0.707), // diagonal
    ];

    // Check collision in multiple directions around the player
    for (const direction of directions) {
      raycaster.set(newPosition, direction);
      const intersects = raycaster.intersectObjects(scene.children, true);

      // Filter out non-solid objects (lights, cameras, etc.)
      const solidIntersects = intersects.filter(intersect => {
        const object = intersect.object;
        // Check if object has geometry and is likely a wall/floor
        return object.geometry && object.material && !object.isLight && !object.isCamera && object.visible;
      });

      if (solidIntersects.length > 0 && solidIntersects[0].distance < playerRadius) {
        return true; // Collision detected
      }
    }
    return false; // No collision
  };

  // Update camera position based on input with collision detection and running animation
  useFrame((state, delta) => {
    if (gameOver) return; // Stop movement when game is over

    const velocity = new Vector3();
    const direction = new Vector3();

    camera.getWorldDirection(direction);
    direction.y = 0; // Keep movement horizontal
    direction.normalize();

    const right = new Vector3();
    right.crossVectors(direction, camera.up).normalize();

    if (keys.current.forward) velocity.add(direction);
    if (keys.current.backward) velocity.sub(direction);
    if (keys.current.right) velocity.add(right);
    if (keys.current.left) velocity.sub(right);

    // Check if player is moving
    const isMoving = velocity.length() > 0;
    isMovingRef.current = isMoving;

    if (isMoving) {
      velocity.normalize();
      velocity.multiplyScalar(moveSpeed * delta);

      // Calculate new position
      const newPosition = camera.position.clone().add(velocity);

      // Check for collision before moving
      if (!checkCollision(newPosition)) {
        camera.position.copy(newPosition);
      } else {
        // Try moving in individual axes if diagonal movement is blocked
        const xMovement = new Vector3(velocity.x, 0, 0);
        const zMovement = new Vector3(0, 0, velocity.z);

        const xPosition = camera.position.clone().add(xMovement);
        const zPosition = camera.position.clone().add(zMovement);

        if (!checkCollision(xPosition)) {
          camera.position.add(xMovement);
        } else if (!checkCollision(zPosition)) {
          camera.position.add(zMovement);
        }
        // If both individual axes are blocked, don't move
      }
    }

    // Handle running animation (head bob)
    if (isMovingRef.current) {
      // Increment bob time when moving
      bobTimeRef.current += delta * bobFrequency;

      // Calculate bobbing offset using sine wave
      const bobOffset = Math.sin(bobTimeRef.current) * bobAmplitude;

      // Apply bobbing to camera Y position
      camera.position.y = baseHeight + bobOffset;
    } else {
      // When not moving, gradually return to base height
      const currentHeight = camera.position.y;
      const heightDiff = baseHeight - currentHeight;

      // Smooth interpolation back to base height
      if (Math.abs(heightDiff) > 0.001) {
        camera.position.y += heightDiff * delta * 5; // Smooth return
      } else {
        camera.position.y = baseHeight;
      }

      // Reset bob time when not moving
      bobTimeRef.current = 0;
    }

    // Update player position for entity tracking
    if (onPositionUpdate) {
      onPositionUpdate(camera.position.clone());
    }
  });

  return null;
}

export default FirstPersonControls;

```

`/home/suhas/Desktop/waitlist/src/components/game/BloodEffect.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";
import * as THREE from "three";

function BloodEffect({ position, onComplete }) {
  const bloodRef = useRef();
  const [opacity, setOpacity] = useState(1);

  useEffect(() => {
    // Load blood texture
    const textureLoader = new THREE.TextureLoader();
    const bloodTexture = textureLoader.load("/blood.png");

    if (bloodRef.current) {
      bloodRef.current.material.map = bloodTexture;
      bloodRef.current.material.transparent = true;
      bloodRef.current.material.needsUpdate = true;
    }

    // Fade out blood effect over 3 seconds
    const fadeInterval = setInterval(() => {
      setOpacity(prev => {
        const newOpacity = prev - 0.02;
        if (newOpacity <= 0) {
          clearInterval(fadeInterval);
          if (onComplete) onComplete();
          return 0;
        }
        return newOpacity;
      });
    }, 50);

    return () => clearInterval(fadeInterval);
  }, [onComplete]);

  useEffect(() => {
    if (bloodRef.current) {
      bloodRef.current.material.opacity = opacity;
    }
  }, [opacity]);

  return (
    <mesh ref={bloodRef} position={position}>
      <planeGeometry args={[0.3, 0.3]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default BloodEffect;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/MobileShootButton.jsx`:

```jsx
import React, { useState } from "react";
import gunImage from "/shott.png";

function MobileShootButton({ onShoot, isVisible }) {
  const [isPressed, setIsPressed] = useState(false);

  const handleStart = e => {
    e.preventDefault();
    e.stopPropagation();

    console.log("üì± Mobile shoot button pressed");
    setIsPressed(true);

    if (onShoot) {
      onShoot();
    } else {
      console.log("‚ùå No onShoot function");
    }
  };

  const handleEnd = e => {
    e.preventDefault();
    e.stopPropagation();
    setIsPressed(false);
    console.log("üì± Mobile shoot button released");
  };

  if (!isVisible) return null;

  return (
    <div
      style={{
        position: "fixed",
        bottom: "40px",
        right: "40px",
        width: "90px",
        height: "90px",
        borderRadius: "50%",
        backgroundColor: isPressed ? "#d8ca05ff" : "#ddd",
        border: "3px solid #fff",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
        touchAction: "none",
        userSelect: "none",
        transform: isPressed ? "scale(0.9)" : "scale(1)",
        transition: "all 0.05s ease",
        boxShadow: isPressed
          ? "0 0 16px rgba(255, 215, 0, 0.8)" // yellow glow
          : "0 4px 12px rgba(0,0,0,0.3)",
        cursor: "pointer",
      }}
      onTouchStart={handleStart}
      onTouchEnd={handleEnd}
      onTouchCancel={handleEnd}
      onMouseDown={handleStart}
      onMouseUp={handleEnd}
      onMouseLeave={handleEnd}
    >
      <img
        src={gunImage}
        alt='Shoot'
        style={{
          width: "70%",
          height: "70%",
          objectFit: "contain",
          pointerEvents: "none",
          filter: "brightness(0) invert(1)",
          rotate: "20deg",
        }}
      />
    </div>
  );
}

export default MobileShootButton;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/VirtualJoystick.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";

function VirtualJoystick({ onJoystickMove, isVisible }) {
  const [isDragging, setIsDragging] = useState(false);
  const [joystickPosition, setJoystickPosition] = useState({ x: 0, y: 0 });
  const [joystickVisible, setJoystickVisible] = useState(false);
  const [joystickCenter, setJoystickCenter] = useState({ x: 80, y: window.innerHeight - 80 });
  const joystickRef = useRef(null);
  const knobRef = useRef(null);
  const activeTouch = useRef(null);

  const maxDistance = 50;
  const deadZone = 0.15;

  const handleStart = e => {
    const touch = e.touches ? e.touches[0] : e;
    const touchX = touch.clientX;
    const touchY = touch.clientY;

    // Only activate if touch is on left side of screen AND no active joystick touch
    if (touchX > window.innerWidth / 2 || activeTouch.current !== null) return;

    e.preventDefault();
    e.stopPropagation(); // Prevent event bubbling

    setJoystickCenter({ x: touchX, y: touchY });
    setJoystickVisible(true);
    setIsDragging(true);
    activeTouch.current = e.touches ? e.touches[0].identifier : "mouse";
  };

  const handleMove = e => {
    if (!isDragging || activeTouch.current === null) return;

    // Find our specific touch
    const touch = e.touches ? Array.from(e.touches).find(t => t.identifier === activeTouch.current) : e;

    if (!touch) return;

    e.preventDefault();
    e.stopPropagation();

    const deltaX = touch.clientX - joystickCenter.x;
    const deltaY = touch.clientY - joystickCenter.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

    let normalizedX = deltaX / maxDistance;
    let normalizedY = deltaY / maxDistance;

    if (distance > maxDistance) {
      normalizedX = deltaX / distance;
      normalizedY = deltaY / distance;
    }

    const normalizedDistance = Math.min(distance / maxDistance, 1);
    if (normalizedDistance < deadZone) {
      normalizedX = 0;
      normalizedY = 0;
    } else {
      const scaledDistance = (normalizedDistance - deadZone) / (1 - deadZone);
      normalizedX *= scaledDistance;
      normalizedY *= scaledDistance;
    }

    setJoystickPosition({
      x: normalizedX * maxDistance,
      y: normalizedY * maxDistance,
    });

    if (onJoystickMove) {
      onJoystickMove({
        x: normalizedX,
        y: -normalizedY,
      });
    }
  };

  const handleEnd = e => {
    // Check if our specific touch ended
    if (e.touches && activeTouch.current !== null) {
      const stillActive = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
      if (stillActive) return; // Our touch is still active
    }

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(false);
    setJoystickVisible(false);
    setJoystickPosition({ x: 0, y: 0 });
    activeTouch.current = null;

    if (onJoystickMove) {
      onJoystickMove({ x: 0, y: 0 });
    }
  };

  useEffect(() => {
    if (!isDragging) return;

    // Add move and end listeners only when dragging
    const moveOptions = { passive: false };
    const endOptions = { passive: false };

    document.addEventListener("touchmove", handleMove, moveOptions);
    document.addEventListener("touchend", handleEnd, endOptions);
    document.addEventListener("touchcancel", handleEnd, endOptions);
    document.addEventListener("mousemove", handleMove, moveOptions);
    document.addEventListener("mouseup", handleEnd, endOptions);

    return () => {
      document.removeEventListener("touchmove", handleMove);
      document.removeEventListener("touchend", handleEnd);
      document.removeEventListener("touchcancel", handleEnd);
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", handleEnd);
    };
  }, [isDragging, joystickCenter, activeTouch.current]);

  useEffect(() => {
    // Listen for touch starts only on left side
    const handleTouchStart = e => {
      if (!isVisible) return;

      const touch = e.touches[0];
      if (touch.clientX <= window.innerWidth / 2) {
        handleStart(e);
      }
    };

    const handleMouseDown = e => {
      if (!isVisible) return;

      if (e.clientX <= window.innerWidth / 2) {
        handleStart(e);
      }
    };

    // Use capture phase to get events first
    document.addEventListener("touchstart", handleTouchStart, { passive: false, capture: true });
    document.addEventListener("mousedown", handleMouseDown, { passive: false, capture: true });

    return () => {
      document.removeEventListener("touchstart", handleTouchStart, { capture: true });
      document.removeEventListener("mousedown", handleMouseDown, { capture: true });
    };
  }, [isVisible]);

  if (!isVisible || !joystickVisible) return null;

  return (
    <div
      ref={joystickRef}
      style={{
        position: "fixed",
        left: joystickCenter.x - maxDistance - 10,
        top: joystickCenter.y - maxDistance - 10,
        width: (maxDistance + 10) * 2,
        height: (maxDistance + 10) * 2,
        borderRadius: "50%",
        backgroundColor: "rgba(255, 255, 255, 0.1)",
        border: "2px solid rgba(255, 255, 255, 0.3)",
        zIndex: 1000,
        pointerEvents: "none",
        userSelect: "none",
      }}
    >
      <div
        ref={knobRef}
        style={{
          position: "absolute",
          width: "30px",
          height: "30px",
          borderRadius: "50%",
          backgroundColor: "rgba(255, 255, 255, 0.9)",
          border: "2px solid rgba(255, 255, 255, 1)",
          left: "50%",
          top: "50%",
          transform: `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`,
          pointerEvents: "none",
          boxShadow: "0 2px 8px rgba(0,0,0,0.3)",
        }}
      />
    </div>
  );
}

export default VirtualJoystick;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/MobileTouchControls.jsx`:

```jsx
// src/components/mobile/MobileTouchControls.jsx
import React, { useState, useRef, useEffect } from "react";
import { useThree } from "@react-three/fiber";
import * as THREE from "three";
import { isMobile } from "../../utils/device";

function MobileTouchControls({ gameOver }) {
  const { camera } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const lastTouch = useRef({ x: 0, y: 0 });
  const sensitivity = 0.007;
  const activeTouch = useRef(null);

  // Define shoot button area to exclude
  const shootButtonArea = {
    right: 40,
    bottom: 40,
    width: 100,
    height: 100,
  };

  // Check if touch is in shoot button area
  const isTouchInShootButton = (touchX, touchY) => {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    const buttonLeft = screenWidth - shootButtonArea.right - shootButtonArea.width;
    const buttonTop = screenHeight - shootButtonArea.bottom - shootButtonArea.height;
    const buttonRight = screenWidth - shootButtonArea.right;
    const buttonBottom = screenHeight - shootButtonArea.bottom;

    return touchX >= buttonLeft && touchX <= buttonRight && touchY >= buttonTop && touchY <= buttonBottom;
  };

  const handleTouchStart = e => {
    if (gameOver) return;

    // Find a touch on the right side that we're not already tracking
    let rightSideTouch = null;
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];

      // Check if touch is on right side AND not in shoot button area
      if (
        touch.clientX > window.innerWidth / 2 &&
        !isTouchInShootButton(touch.clientX, touch.clientY) &&
        (activeTouch.current === null || activeTouch.current !== touch.identifier)
      ) {
        rightSideTouch = touch;
        break;
      }
    }

    if (!rightSideTouch || activeTouch.current !== null) return;

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(true);
    activeTouch.current = rightSideTouch.identifier;
    lastTouch.current = {
      x: rightSideTouch.clientX,
      y: rightSideTouch.clientY,
    };
  };

  const handleTouchMove = e => {
    if (!isDragging || activeTouch.current === null || gameOver) return;

    // Find our specific touch
    const touch = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
    if (!touch) return;

    e.preventDefault();
    e.stopPropagation();

    const deltaX = touch.clientX - lastTouch.current.x;
    const deltaY = touch.clientY - lastTouch.current.y;

    // Store current rotations
    const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, "YXZ");

    // Apply rotations
    euler.y -= deltaX * sensitivity;
    euler.x -= deltaY * sensitivity;
    euler.z = 0; // Prevent tilting

    // Clamp vertical rotation
    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

    // Apply back to camera
    camera.quaternion.setFromEuler(euler);

    lastTouch.current = {
      x: touch.clientX,
      y: touch.clientY,
    };
  };

  const handleTouchEnd = e => {
    if (activeTouch.current === null) return;

    // Check if our specific touch ended
    const touchStillActive = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
    if (touchStillActive) return; // Our touch is still active

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(false);
    activeTouch.current = null;
  };

  useEffect(() => {
    if (!isMobile() || gameOver) return;

    // Use capture phase to handle events before they bubble
    const options = { passive: false, capture: true };

    const startHandler = e => {
      // Only handle touches on right side that are NOT in shoot button area
      const hasValidRightSideTouch = Array.from(e.touches).some(
        touch => touch.clientX > window.innerWidth / 2 && !isTouchInShootButton(touch.clientX, touch.clientY)
      );

      if (hasValidRightSideTouch) {
        handleTouchStart(e);
      }
    };

    const moveHandler = e => {
      if (isDragging) {
        handleTouchMove(e);
      }
    };

    const endHandler = e => {
      if (isDragging) {
        handleTouchEnd(e);
      }
    };

    document.addEventListener("touchstart", startHandler, options);
    document.addEventListener("touchmove", moveHandler, options);
    document.addEventListener("touchend", endHandler, options);
    document.addEventListener("touchcancel", endHandler, options);

    return () => {
      document.removeEventListener("touchstart", startHandler, { capture: true });
      document.removeEventListener("touchmove", moveHandler, { capture: true });
      document.removeEventListener("touchend", endHandler, { capture: true });
      document.removeEventListener("touchcancel", endHandler, { capture: true });
    };
  }, [isDragging, gameOver, activeTouch.current]);

  return null;
}

export default MobileTouchControls;

```

`/home/suhas/Desktop/waitlist/src/components/ui/Join.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";

function Join() {
  const [username, setUsername] = useState("");
  const [showLinks, setShowLinks] = useState(false);
  const [inputDisabled, setInputDisabled] = useState(false);
  const [showCursor, setShowCursor] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitStatus, setSubmitStatus] = useState("");
  const inputRef = useRef(null);

  useEffect(() => {
    if (inputRef.current && !inputDisabled) {
      inputRef.current.focus();
    }
  }, [inputDisabled]);

  // Function to send data to SheetDB
  const submitToSheetDB = async username => {
    try {
      const currentTime = new Date();
      const formattedTime = currentTime.toLocaleString("en-US", {
        day: "2-digit",
        month: "short",
        year: "numeric",
        hour: "numeric",
        minute: "numeric",
        hour12: true,
      });

      // Generate serial number (timestamp-based to ensure uniqueness)
      const serialNumber = Date.now();

      const dataToSend = {
        data: [
          {
            "sl.no": serialNumber,
            "username": String(username),
            "time": formattedTime,
          },
        ],
      };

      console.log("Sending this data to SheetDB:", dataToSend);

      const response = await fetch("https://sheetdb.io/api/v1/e3qzzdsccl9j2", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(dataToSend),
      });

      if (response.ok) {
        const result = await response.json();
        console.log("Data saved successfully to SheetDB:", result);
        setSubmitStatus("‚úÖ Successfully added to waitlist!");
        return true;
      } else {
        const errorData = await response.text();
        console.error("Error saving data. Status:", response.status, "Response:", errorData);
        setSubmitStatus("‚ùå Error adding to waitlist. Please try again.");
        return false;
      }
    } catch (error) {
      console.error("Error during fetch:", error);
      setSubmitStatus("‚ùå Network error. Please check your connection.");
      return false;
    }
  };

  const handleKeyPress = async e => {
    if (e.key === "Enter" && username.trim() && !isSubmitting) {
      setIsSubmitting(true);
      setInputDisabled(true);
      setShowCursor(false);
      setSubmitStatus("‚è≥ Adding to waitlist...");

      // Submit to SheetDB
      const success = await submitToSheetDB(username.trim());

      if (success) {
        // Show links after successful submission
        setTimeout(() => {
          setShowLinks(true);
        }, 1000);
      } else {
        // Re-enable input on error
        setInputDisabled(false);
        setShowCursor(true);
      }

      setIsSubmitting(false);
    }
  };

  const handleFocus = () => {
    setShowCursor(false);
  };

  const handleBlur = () => {
    if (!inputDisabled) {
      setShowCursor(true);
    }
  };

  const handleClick = () => {
    if (!inputDisabled && inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div
      className='terminal'
      onClick={handleClick}
      style={{
        width: "100%",
        height: "100vh",
        padding: "20px",
        backgroundColor: "#000",
        color: "#00ff00",
        fontFamily: "'Jersey 15', monospace",
        fontSize: "30px",
        lineHeight: "1.4",
        overflow: "hidden",
      }}
    >
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Jersey+15&display=swap');

          body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }

          .terminal {
            overflow-y: auto;
          }

          .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background-color: #00ff00;
            animation: blink 1s infinite;
          }

          @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
          }

          .terminal-input {
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Jersey 15', monospace;
            font-size: 30px;
            outline: none;
            flex: 1;
          }

          .links a {
            color: #00ff00;
            text-decoration: underline;
          }

          .links a:hover {
            color: #00ffff;
          }

          .status-message {
            font-size: 20px;
            margin-top: 10px;
            opacity: 0.8;
          }

          .success-message {
            color: #00ff00;
          }

          .error-message {
            color: #ff6b6b;
          }

          .loading-message {
            color: #ffff00;
          }
        `}
      </style>

      <div style={{ marginBottom: "20px", whiteSpace: "pre" }}>
        {`‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ïó‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ï¶‚ïù‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ïö‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïê‚ïù‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñë
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó‚ñë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñë‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ï¶‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñë‚ñë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñë‚ïö‚ïê‚ïù‚ñë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïù‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ñë‚ïö‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë‚ïö‚ïê‚ïù‚ñë‚ñë‚ñë‚ñë‚ñë‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ñë`}
      </div>

      <div style={{ marginTop: "30px" }}>
        <div>Enter your Discord Username to join the waitlist</div>
        <div style={{ display: "flex", alignItems: "center" }}>
          <span style={{ marginRight: "5px" }}>{">"}</span>
          <input
            ref={inputRef}
            type='text'
            value={username}
            onChange={e => setUsername(e.target.value)}
            onKeyPress={handleKeyPress}
            onFocus={handleFocus}
            onBlur={handleBlur}
            disabled={inputDisabled}
            className='terminal-input'
            autoComplete='off'
            placeholder={inputDisabled ? "" : "your_discord_username"}
          />
          {showCursor && <span className='cursor'></span>}
        </div>

        {/* Status Message */}
        {submitStatus && (
          <div
            className={`status-message ${
              submitStatus.includes("‚úÖ") ? "success-message" : submitStatus.includes("‚ùå") ? "error-message" : "loading-message"
            }`}
          >
            {submitStatus}
          </div>
        )}

        {showLinks && (
          <div className='links' style={{ marginTop: "20px" }}>
            <div style={{ marginBottom: "10px", fontSize: "24px" }}>Welcome to the waitlist! Join our community:</div>
            <div>
              Twitter:{" "}
              <a href='https://x.com/_BlockRooms' target='_blank' rel='noopener noreferrer'>
                https://x.com/_BlockRooms
              </a>
            </div>
            <div>
              Discord:{" "}
              <a href='https://discord.com/invite/jcpgh3KS3z' target='_blank' rel='noopener noreferrer'>
                https://discord.com/invite/jcpgh3KS3z
              </a>
            </div>
            <div style={{ marginTop: "15px", fontSize: "18px", opacity: "0.7" }}>
              You'll receive updates via Discord. Keep an eye on your DMs!
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default Join;

```

`/home/suhas/Desktop/waitlist/src/components/ui/WarningDialog.jsx`:

```jsx
import React, { useEffect, useState } from "react";

function WarningDialog({ onAccept }) {
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [loadingText, setLoadingText] = useState("Loading assets...");
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Simplified loading - just simulate progress
    let progress = 0;
    const interval = setInterval(() => {
      progress += Math.random() * 15; // Random progress increments

      if (progress >= 100) {
        progress = 100;
        setLoadingProgress(100);
        setLoadingText("Loading complete!");
        setTimeout(() => {
          setIsLoaded(true);
          clearInterval(interval);
        }, 500);
      } else {
        setLoadingProgress(progress);
      }
    }, 200);

    // Fallback - force complete after 3 seconds
    const fallback = setTimeout(() => {
      setLoadingProgress(100);
      setLoadingText("Ready to play!");
      setIsLoaded(true);
      clearInterval(interval);
    }, 3000);

    return () => {
      clearInterval(interval);
      clearTimeout(fallback);
    };
  }, []);

  const handleClick = () => {
    if (isLoaded && onAccept) {
      console.log("OK button clicked, calling onAccept");
      onAccept();
    } else {
      console.log("Button not ready:", { isLoaded, onAccept });
    }
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        zIndex: 20000,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <div
        style={{
          width: "450px",
          height: "250px",
          backgroundColor: "#c0c0c0",
          border: "2px outset #c0c0c0",
          fontFamily: "MS Sans Serif, sans-serif",
          fontSize: "11px",
        }}
      >
        {/* Title Bar */}
        <div
          style={{
            height: "20px",
            background: "linear-gradient(90deg, #0000ff 0%, #008080 100%)",
            color: "white",
            display: "flex",
            alignItems: "center",
            padding: "2px 8px",
            fontSize: "14px",
            fontWeight: "bold",
          }}
        >
          <span>BlockRooms</span>
        </div>

        {/* Content Area */}
        <div
          style={{
            padding: "20px",
            height: "230px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            textAlign: "center",
          }}
        >
          <div
            style={{
              fontSize: "15px",
              marginBottom: "30px",
              lineHeight: "1.4",
            }}
          >
            This is just a waitlist site and not the actual gameplay.
          </div>

          {/* Loading Section */}
          <div style={{ width: "100%", marginBottom: "30px" }}>
            <div
              style={{
                fontSize: "12px",
                marginBottom: "10px",
                textAlign: "left",
              }}
            >
              {loadingText}
            </div>

            {/* Progress Bar */}
            <div
              style={{
                width: "100%",
                height: "20px",
                border: "2px inset #c0c0c0",
                backgroundColor: "#ffffff",
                position: "relative",
                overflow: "hidden",
              }}
            >
              <div
                style={{
                  height: "100%",
                  width: `${loadingProgress}%`,
                  background: "linear-gradient(90deg, #316AC5 0%, #52A6F5 50%, #316AC5 100%)",
                  transition: "width 0.3s ease",
                }}
              />
            </div>

            <div
              style={{
                fontSize: "11px",
                marginTop: "5px",
                textAlign: "right",
                color: "#666",
              }}
            >
              {Math.round(loadingProgress)}%
            </div>
          </div>

          {/* OK Button */}
          <div style={{ display: "flex", justifyContent: "center" }}>
            <button
              onClick={handleClick}
              style={{
                width: "100px",
                height: "30px",
                backgroundColor: isLoaded ? "#c0c0c0" : "#d4d0c8",
                border: isLoaded ? "3px outset #c0c0c0" : "2px inset #d4d0c8",
                fontSize: "15px",
                cursor: isLoaded ? "pointer" : "not-allowed",
                fontFamily: "MS Sans Serif, sans-serif",
                color: isLoaded ? "#000000" : "#808080",
                opacity: isLoaded ? 1 : 0.6,
              }}
            >
              {isLoaded ? "Ok" : "Loading..."}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

export default WarningDialog;

```

`/home/suhas/Desktop/waitlist/src/components/ui/DeathScreen.jsx`:

```jsx
// src/components/ui/DeathScreen.jsx
import React, { useEffect, useState } from "react";

function DeathScreen({ onJoin }) {
  const [showTV, setShowTV] = useState(false);
  const [showJoinText, setShowJoinText] = useState(false);

  useEffect(() => {
    // Automatically unlock cursor when death screen appears
    if (document.pointerLockElement) {
      document.exitPointerLock();
    }

    // Show TV image after 3 seconds
    const tvTimeout = setTimeout(() => {
      setShowTV(true);
    }, 3000);

    // Show join text after 6 seconds
    const joinTextTimeout = setTimeout(() => {
      setShowJoinText(true);
    }, 6000);

    return () => {
      clearTimeout(tvTimeout);
      clearTimeout(joinTextTimeout);
    };
  }, []);

  const handleClick = () => {
    if (showJoinText && onJoin) {
      onJoin();
    }
  };

  return (
    <div
      onClick={handleClick}
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        backgroundColor: "black",
        zIndex: 10000,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        cursor: showJoinText ? "pointer" : "default",
        overflow: "hidden",
      }}
    >
      {showTV && (
        <div style={{ position: "relative", width: "100vw", height: "100vh" }}>
          <img
            src='/tv2.png'
            alt='TV'
            style={{
              width: "100vw",
              height: "100vh",
              objectFit: "cover",
              display: "block",
            }}
          />
          {showJoinText && (
            <div
              style={{
                position: "absolute",
                bottom: "10%",
                left: "50%",
                transform: "translateX(-50%)",
                color: "white",
                fontSize: "24px",
                fontFamily: "Arial, sans-serif",
                fontWeight: "bold",
                textAlign: "center",
                textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
                animation: "pulse 2s infinite",
                userSelect: "none",
                whiteSpace: "nowrap",
              }}
            >
              tap anywhere to join
            </div>
          )}
        </div>
      )}

      <style jsx>{`
        @keyframes pulse {
          0% {
            opacity: 1;
          }
          50% {
            opacity: 0.5;
          }
          100% {
            opacity: 1;
          }
        }
      `}</style>
    </div>
  );
}

export default DeathScreen;

```

`/home/suhas/Desktop/waitlist/src/index.jsx`:

```jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App"; // Keep this as ./App for now
import "./styles.css";

const root = createRoot(document.getElementById("root"));
root.render(<App />);

```

`/home/suhas/Desktop/waitlist/src/Gun1.jsx`:

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/gun1.glb 
Author: DJMaesen (https://sketchfab.com/bumstrum)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/animated-pistol-bd896167e7ca44f19597d3afe6a8d83f
Title: animated pistol
*/

import React from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";

export function Model(props) {
  const group = React.useRef();
  const { scene, animations } = useGLTF("/gun1.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(animations, group);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name='Sketchfab_Scene'>
        <group name='Sketchfab_model' rotation={[-Math.PI / 2, 0, 0]}>
          <group name='105d2810571c4501ba07ac55c5582245fbx' rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name='Object_2'>
              <group name='RootNode'>
                <group name='Root' position={[0, 16.327, -8.923]}>
                  <group name='Object_5'>
                    <group name='pistol' position={[0, -12.318, 25.913]}>
                      <group name='stopper' position={[1.26, 5.502, 5.615]}>
                        <mesh name='stopper_beretta_0' geometry={nodes.stopper_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='mag' position={[0, -0.379, 0.406]} rotation={[0.262, 0, 0]}>
                        <group name='shell' position={[0, 7.4, -0.455]} rotation={[-0.262, 0, 0]}>
                          <group name='bullet_2_2' position={[0, 0, 0.935]}>
                            <mesh name='bullet_2_2_beretta_0' geometry={nodes.bullet_2_2_beretta_0.geometry} material={materials.beretta} />
                          </group>
                          <mesh name='shell_beretta_0' geometry={nodes.shell_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <group name='shell_1_2' position={[0, 6.293, -0.158]} rotation={[-0.262, 0, 0]}>
                          <group name='bullet' position={[0, 0, 0.935]}>
                            <mesh name='bullet_beretta_0' geometry={nodes.bullet_beretta_0.geometry} material={materials.beretta} />
                          </group>
                          <mesh name='shell_1_2_beretta_0' geometry={nodes.shell_1_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <mesh name='mag_beretta_0' geometry={nodes.mag_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='hammer' position={[0, 5.573, -1.608]} rotation={[-1.242, 0, 0]}>
                        <mesh name='hammer_beretta_0' geometry={nodes.hammer_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='trigger' position={[0, 4.404, 6.033]}>
                        <mesh name='trigger_beretta_0' geometry={nodes.trigger_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='slide' position={[0, 7.341, 3.872]}>
                        <mesh name='slide_beretta_0' geometry={nodes.slide_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='base'>
                        <mesh name='base_beretta_0' geometry={nodes.base_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='shell_1' position={[0, 7.849, 6.937]}>
                        <group name='bullet_2' position={[0, 0, 0.935]}>
                          <mesh name='bullet_2_beretta_0' geometry={nodes.bullet_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <mesh name='shell_1_beretta_0' geometry={nodes.shell_1_beretta_0.geometry} material={materials.beretta} />
                      </group>
                    </group>
                    <primitive object={nodes._rootJoint} />
                    <group name='Object_82' position={[0, 3.036, -1.334]} />
                    <skinnedMesh
                      name='Object_83'
                      geometry={nodes.Object_83.geometry}
                      material={materials.arms}
                      skeleton={nodes.Object_83.skeleton}
                    />
                  </group>
                </group>
                <group name='armsmesh' position={[0, 3.036, -1.334]} rotation={[-0.002, 0, -0.011]} />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/gun1.glb");

```

`/home/suhas/Desktop/waitlist/src/styles.css`:

```css
/* Prevent mobile browser zoom and selection */
* {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* Prevent zoom on double tap */
body {
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-text-size-adjust: none;
  -webkit-user-select: none;
  user-select: none;
}

/* Prevent iOS Safari bounce and zoom */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100dvh; 
  overflow: hidden;
  background: black;
}

/* Prevent zoom on input focus (if any) */
input,
textarea,
select {
  font-size: 16px !important;
  -webkit-user-select: text;
  user-select: text;
}

/* Game canvas specific */
canvas {
  touch-action: none;
  -webkit-touch-callout: none;
  display: block;
  position: absolute;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
}


```