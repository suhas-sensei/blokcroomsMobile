Project Path: src

Source Tree:

```
src
├── utils
│   ├── fullscreen.js
│   └── device.js
├── Model.jsx
├── lib
│   └── supabase.js
├── App.jsx
├── components
│   ├── game
│   │   ├── BulletHole.jsx
│   │   ├── Instructions.jsx
│   │   ├── Gun.jsx
│   │   ├── Entity.jsx
│   │   ├── AudioManager.jsx
│   │   ├── FirstPersonControls.jsx
│   │   └── BloodEffect.jsx
│   ├── mobile
│   │   ├── MobileShootButton.jsx
│   │   ├── VirtualJoystick.jsx
│   │   └── MobileTouchControls.jsx
│   └── ui
│       ├── Join.jsx
│       ├── WarningDialog.jsx
│       └── DeathScreen.jsx
├── index.jsx
├── Gun1.jsx
└── styles.css

```

`/home/suhas/Desktop/waitlist/src/utils/fullscreen.js`:

```js
export const requestFullscreen = () => {
  const element = document.documentElement;
  
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }
};

export const lockOrientation = () => {
  if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock('landscape').catch(err => {
      console.log('Orientation lock failed:', err);
    });
  } else if (screen.lockOrientation) {
    screen.lockOrientation('landscape');
  } else if (screen.webkitLockOrientation) {
    screen.webkitLockOrientation('landscape');
  } else if (screen.mozLockOrientation) {
    screen.mozLockOrientation('landscape');
  }
};

export const hideAddressBar = () => {
  // Hide address bar on mobile
  setTimeout(() => {
    window.scrollTo(0, 1);
  }, 100);
};
```

`/home/suhas/Desktop/waitlist/src/utils/device.js`:

```js
export const isMobile = () => {
  // First check for touch capability
  const hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;

  // Then check user agent
  const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

  // Check screen size
  const isSmallScreen = window.innerWidth <= 768;

  // Force mobile if any condition is true
  return hasTouch || isMobileUA || isSmallScreen;
};

```

`/home/suhas/Desktop/waitlist/src/Model.jsx`:

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model.glb 
Author: Huuxloc (https://sketchfab.com/rjh41)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/original-backrooms-e5c6b30995ff442d9852a1dd697aaef1
Title: Original Backrooms
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

export function Model(props) {
  const { nodes, materials } = useGLTF('/model.glb')
  return (
    <group {...props} dispose={null}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={1.25}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.5, 1.416, -2.739]} rotation={[0, -Math.PI / 2, 0]}>
            <mesh geometry={nodes.Object_8.geometry} material={materials.PlugSocket} />
            <mesh geometry={nodes.Object_9.geometry} material={materials.GreenSkirting} />
            <mesh geometry={nodes.Object_10.geometry} material={materials.BR_2} />
            <mesh geometry={nodes.Object_11.geometry} material={materials.StripeWallpaper} />
            <mesh geometry={nodes.Object_12.geometry} material={materials.Dot_Wallpaper} />
          </group>
          <group position={[-3.842, 2.143, 1.4]}>
            <mesh geometry={nodes.Object_16.geometry} material={materials.Ceiling_Grid} />
            <mesh geometry={nodes.Object_17.geometry} material={materials.Ceiling_Lights} />
          </group>
          <mesh geometry={nodes.Object_4.geometry} material={materials.Vent} position={[-2.246, 2.15, -1.332]} />
          <mesh geometry={nodes.Object_6.geometry} material={materials.Piece1} position={[-5.461, 1.416, 5.699]} rotation={[-Math.PI, 0, -Math.PI]} />
          <mesh geometry={nodes.Object_14.geometry} material={materials.NewCarpet} position={[0.016, 0.006, -5.539]} />
          <mesh geometry={nodes.Object_19.geometry} material={materials.CeilingTile} position={[-3.842, 2.143, 1.4]} />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/model.glb')

```

`/home/suhas/Desktop/waitlist/src/lib/supabase.js`:

```js
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

export const supabase = createClient(supabaseUrl, supabaseKey);
```

`/home/suhas/Desktop/waitlist/src/App.jsx`:

```jsx
import React, { useRef, useState, useEffect } from "react"; 
import { Canvas } from "@react-three/fiber";
import { PointerLockControls } from "@react-three/drei";
import { Vector3 } from "three";
import { Model } from "../src/Model";
import { Model as GunModel } from "../src/Gun1";

// Utility imports
import { isMobile } from "../src/utils/device";
import { requestFullscreen, lockOrientation, hideAddressBar } from "../src/utils/fullscreen";

// UI components
import WarningDialog from "../src/components/ui/WarningDialog";
import DeathScreen from "../src/components/ui/DeathScreen";
import Join from "../src/components/ui/Join";

// Mobile components
import VirtualJoystick from "../src/components/mobile/VirtualJoystick";
import MobileTouchControls from "../src/components/mobile/MobileTouchControls";
import MobileShootButton from "../src/components/mobile/MobileShootButton";

// Game components
import Gun from "../src/components/game/Gun";
import Entity from "../src/components/game/Entity";
import BloodEffect from "../src/components/game/BloodEffect";
import BulletHole from "../src/components/game/BulletHole";
import AudioManager from "../src/components/game/AudioManager";
import FirstPersonControls from "../src/components/game/FirstPersonControls";
import Instructions from "../src/components/game/Instructions";

const App = () => {
  // State declarations
  const [playerPosition, setPlayerPosition] = useState(new Vector3(0, 1.6, 0));
  const [entityDistance, setEntityDistance] = useState(null);
  const [gameOver, setGameOver] = useState(false);
  const [showGun, setShowGun] = useState(true);
  const [bloodEffects, setBloodEffects] = useState([]);
  const [bulletHoles, setBulletHoles] = useState([]);
  const [showJoinPage, setShowJoinPage] = useState(false);
  const [showWarning, setShowWarning] = useState(true);
  const [entityActive, setEntityActive] = useState(false);
  const [mobileMovement, setMobileMovement] = useState({ x: 0, y: 0 });

  // Refs
  const entityRef = useRef();
  const shootFunctionRef = useRef(null);
  const mobile = isMobile();

  // Fullscreen and mobile optimization effect - MOBILE ONLY
  useEffect(() => {
    // Only apply fullscreen features on mobile devices
    if (!mobile) return;
    
    // Hide address bar and setup fullscreen for mobile
    hideAddressBar();
    
    // Try to lock orientation to landscape
    lockOrientation();
    
    // Request fullscreen on first user interaction
    const handleFirstTouch = () => {
      requestFullscreen();
      document.removeEventListener('touchstart', handleFirstTouch);
      document.removeEventListener('click', handleFirstTouch);
    };
    
    document.addEventListener('touchstart', handleFirstTouch);
    document.addEventListener('click', handleFirstTouch);
    
    return () => {
      document.removeEventListener('touchstart', handleFirstTouch);
      document.removeEventListener('click', handleFirstTouch);
    };
  }, [mobile]);

  // Event handlers
  const handleEntityCatch = () => {
    setGameOver(true);
  };

  const handleDistanceUpdate = distance => {
    setEntityDistance(distance);
  };

  const handlePositionUpdate = position => {
    setPlayerPosition(position);
  };

  const handleAudioStop = () => {
    console.log("All audio stopped, player is dead");
  };

  const handleJoin = () => {
    console.log("Redirecting to join page");
    setShowJoinPage(true);
  };

  const handleWarningAccept = () => {
    setShowWarning(false);
    
    // Request fullscreen and lock orientation when game starts - MOBILE ONLY
    if (mobile) {
      requestFullscreen();
      lockOrientation();
    }
    
    // Spawn entity after 3 seconds
    setTimeout(() => {
      setEntityActive(true);
    }, 3000);
  };

  const handleJoystickMove = movement => {
    setMobileMovement(movement);
  };

  const handleMobileShoot = () => {
    console.log("🎯 handleMobileShoot called");
    if (shootFunctionRef.current) {
      console.log("✅ Calling shoot function");
      shootFunctionRef.current();
    } else {
      console.log("❌ No shoot function reference available");
    }
  };

  const handleShoot = (hit, cameraPosition) => {
    if (gameOver) return;

    const hitObject = hit.object;
    const hitPoint = hit.point;
    const hitNormal = hit.face.normal;

    if (hitObject.userData?.isEntity) {
      const bloodId = Date.now() + Math.random();
      setBloodEffects(prev => [
        ...prev,
        {
          id: bloodId,
          position: hitPoint.clone(),
        },
      ]);
    } else {
      const holeId = Date.now() + Math.random();
      const offsetPosition = hitPoint.clone().add(hitNormal.clone().multiplyScalar(0.01));
      setBulletHoles(prev => [
        ...prev,
        {
          id: holeId,
          position: offsetPosition,
          normal: hitNormal.clone(),
          cameraPosition: cameraPosition.clone(),
        },
      ]);
    }
  };

  const handleShootWithRef = {
    shootHandler: (hit, cameraPosition) => {
      handleShoot(hit, cameraPosition);
    },
    setShootFunction: shootFn => {
      shootFunctionRef.current = shootFn;
    },
  };

  const removeBloodEffect = id => {
    setBloodEffects(prev => prev.filter(effect => effect.id !== id));
  };

  const removeBulletHole = id => {
    setBulletHoles(prev => prev.filter(hole => hole.id !== id));
  };

  // Show join page if requested
  if (showJoinPage) {
    return <Join />;
  }

  return (
    <div style={{ width: "100vw", height: "100vh", position: "relative" }}>
      {/* Single Warning Dialog */}
      {showWarning && <WarningDialog onAccept={handleWarningAccept} />}
      
      {/* Audio Manager - silent background component */}
      <AudioManager 
        entityDistance={entityDistance} 
        gameOver={gameOver} 
        onAudioStop={handleAudioStop} 
      />
      
      {/* Death Screen */}
      {gameOver && <DeathScreen onJoin={handleJoin} />}

      {/* Mobile Controls - only show when game is active */}
      {mobile && !gameOver && !showWarning && (
        <>
          <VirtualJoystick onJoystickMove={handleJoystickMove} isVisible={true} />
          <MobileShootButton onShoot={handleMobileShoot} isVisible={true} />
        </>
      )}

      {/* Game Instructions */}
      <Instructions gameOver={gameOver} />

      {/* Main 3D Canvas */}
      <Canvas
        camera={{
          fov: 75,
          position: [0, 1.6, 0],
          rotation: [0, 0, 0],
          near: 0.1,
          far: 1000,
        }}
        onCreated={({ camera }) => {
          camera.rotation.set(0, 0, 0);
          camera.lookAt(0, 1.6, -1);
        }}
      >
        {/* Lighting */}
        <ambientLight intensity={0.4} color='#fff8dc' />
        <directionalLight position={[5, 5, 5]} intensity={0.6} color='#fff8dc' castShadow />
        <directionalLight position={[-5, 3, -5]} intensity={0.3} color='#f4e4bc' />

        {/* Controls */}
        {!mobile && <PointerLockControls />}
        {mobile && <MobileTouchControls gameOver={gameOver} />}
        
        {/* First Person Movement Controller */}
        <FirstPersonControls 
          onPositionUpdate={handlePositionUpdate} 
          gameOver={gameOver} 
          mobileMovement={mobileMovement} 
        />
        
        {/* 3D Models */}
        <Model />
        <Gun isVisible={showGun} onShoot={handleShootWithRef} />
        
        {/* Entity - only spawns when entityActive is true */}
        {entityActive && !gameOver && (
          <Entity 
            playerPosition={playerPosition} 
            onCatch={handleEntityCatch} 
            onDistanceUpdate={handleDistanceUpdate} 
          />
        )}

        {/* Visual Effects */}
        {bloodEffects.map(effect => (
          <BloodEffect 
            key={effect.id} 
            position={effect.position} 
            onComplete={() => removeBloodEffect(effect.id)} 
          />
        ))}

        {bulletHoles.map(hole => (
          <BulletHole
            key={hole.id}
            position={hole.position}
            normal={hole.normal}
            cameraPosition={hole.cameraPosition}
            onComplete={() => removeBulletHole(hole.id)}
          />
        ))}
      </Canvas>
    </div>
  );
};

export default App;
```

`/home/suhas/Desktop/waitlist/src/components/game/BulletHole.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import * as THREE from "three";

function BulletHole({ position, normal, cameraPosition, onComplete }) {
  const holeRef = useRef();

  useEffect(() => {
    // Load hole texture
    const textureLoader = new THREE.TextureLoader();
    const holeTexture = textureLoader.load("/hole.png");

    if (holeRef.current) {
      holeRef.current.material.map = holeTexture;
      holeRef.current.material.transparent = true;
      holeRef.current.material.needsUpdate = true;

      // Orient the hole to face towards the camera (player)
      holeRef.current.lookAt(cameraPosition);
    }

    // Remove bullet hole after 10 seconds
    const removeTimeout = setTimeout(() => {
      if (onComplete) onComplete();
    }, 10000);

    return () => clearTimeout(removeTimeout);
  }, [position, normal, cameraPosition, onComplete]);

  return (
    <mesh ref={holeRef} position={position}>
      <planeGeometry args={[0.15, 0.15]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default BulletHole;

```

`/home/suhas/Desktop/waitlist/src/components/game/Instructions.jsx`:

```jsx
import React from "react";
import { isMobile } from "../../utils/device";

function Instructions({ gameOver }) {
  if (gameOver) return null; // Hide instructions when game is over

  const mobile = isMobile();

  // You can add instruction rendering logic here if needed
  // For now, returning null as the original component was empty
  return null;
}

export default Instructions;

```

`/home/suhas/Desktop/waitlist/src/components/game/Gun.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Vector3, Raycaster } from "three";
import * as THREE from "three";
import { Model as GunModel } from "../../Gun1"; // Import the gun model
import { isMobile } from "../../utils/device";

function Gun({ isVisible = true, onShoot }) {
  const gunRef = useRef();
  const { camera, scene } = useThree();

  // Timer to drive breathing motion
  const swayTime = useRef(0);

  // Visual recoil state (doesn't block shooting)
  const [visualRecoil, setVisualRecoil] = useState(false);
  const recoilTime = useRef(0);
  const shootSound = useRef(null);

  // Load and apply textures
  useEffect(() => {
    // Load shoot sound
    const audio = new Audio("/shot.mp3");
    audio.volume = 0.7;
    shootSound.current = audio;

    if (gunRef.current) {
      const textureLoader = new THREE.TextureLoader();

      // Load beretta (gun) textures
      const berettaColor = textureLoader.load("/textures/berettaColor.png");
      const berettaNormal = textureLoader.load("/textures/berettaNormal.png");
      const berettaMetallic = textureLoader.load("/textures/berettaMetallic.png");
      const berettaRoughness = textureLoader.load("/textures/berettaRoughness.png");
      const berettaAO = textureLoader.load("/textures/berettaAO.png");

      // Load arms textures
      const armsColor = textureLoader.load("/textures/armsColor.png");
      const armsNormal = textureLoader.load("/textures/armsNormal.png");
      const armsRoughness = textureLoader.load("/textures/armsRoughness.png");
      const armsAO = textureLoader.load("/textures/armsAO.png");

      // Apply textures to materials
      gunRef.current.traverse(child => {
        if (child.isMesh && child.material) {
          const material = child.material;

          if (material.name === "beretta") {
            material.map = berettaColor;
            material.normalMap = berettaNormal;
            material.metalnessMap = berettaMetallic;
            material.roughnessMap = berettaRoughness;
            material.aoMap = berettaAO;
            material.metalness = 1.0;
            material.roughness = 0.4;
            material.aoMapIntensity = 1.0;
            child.castShadow = true;
            child.receiveShadow = true;
            material.needsUpdate = true;
          }

          if (material.name === "arms") {
            material.map = armsColor;
            material.normalMap = armsNormal;
            material.roughnessMap = armsRoughness;
            material.aoMap = armsAO;
            material.metalness = 0.0;
            material.roughness = 0.8;
            material.aoMapIntensity = 1.0;
            child.castShadow = true;
            child.receiveShadow = true;
            material.needsUpdate = true;
          }
        }
      });
    }

    // Add mouse click event listener for shooting (only for non-mobile)
    const handleMouseClick = event => {
      if (event.button === 0 && isVisible && !isMobile()) {
        shoot();
      }
    };

    if (!isMobile()) {
      document.addEventListener("mousedown", handleMouseClick);
    }

    return () => {
      if (!isMobile()) {
        document.removeEventListener("mousedown", handleMouseClick);
      }
      if (shootSound.current) {
        shootSound.current = null;
      }
    };
  }, [isVisible]);

  // Shoot function - can always shoot
  const shoot = () => {
    console.log("🔫 SHOOTING - No blocks, always fires!");

    // Play shoot sound (create new audio instance each time for rapid fire)
    if (shootSound.current) {
      try {
        // Clone the audio for rapid fire
        const shotAudio = shootSound.current.cloneNode();
        shotAudio.volume = 0.7;
        shotAudio.currentTime = 0;
        shotAudio.play().catch(error => {
          console.log("Failed to play shoot sound:", error);
        });
      } catch (error) {
        console.log("Audio clone failed, using original:", error);
        shootSound.current.currentTime = 0;
        shootSound.current.play().catch(err => {
          console.log("Original audio failed too:", err);
        });
      }
    }

    // Perform raycast from camera center
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(camera.quaternion);

    raycaster.set(camera.position, direction);
    const intersects = raycaster.intersectObjects(scene.children, true);

    // Filter out gun and non-solid objects
    const validIntersects = intersects.filter(intersect => {
      const object = intersect.object;
      return (
        !object.isLight &&
        !object.isCamera &&
        !gunRef.current?.children.some(child => child === object || child.children.includes(object)) &&
        (object.userData?.isEntity || (object.geometry && object.material)) &&
        object.visible
      );
    });

    if (validIntersects.length > 0 && onShoot?.shootHandler) {
      const hit = validIntersects[0];
      console.log("🎯 HIT DETECTED:", hit.object);
      onShoot.shootHandler(hit, camera.position);
    }

    // Start VISUAL recoil animation (doesn't block shooting)
    setVisualRecoil(true);
    recoilTime.current = 0;

    // End visual recoil quickly
    setTimeout(() => {
      setVisualRecoil(false);
    }, 80); // Very short visual recoil
  };

  // Expose shoot function to parent component
  useEffect(() => {
    if (onShoot && onShoot.setShootFunction) {
      console.log("🔗 Setting shoot function reference");
      onShoot.setShootFunction(shoot);
    }
  }, [onShoot]);

  useFrame((_, delta) => {
    if (!gunRef.current || !isVisible) return;

    // Increment sway timer
    swayTime.current += delta;

    // Breathing sway amount
    const swayY = Math.sin(swayTime.current * 2) * 0.01;

    // Base position from camera
    const gunPosition = new THREE.Vector3();
    camera.getWorldPosition(gunPosition);

    const forward = new THREE.Vector3(0, 0, -1);
    const right = new THREE.Vector3(1, 0, 0);
    const down = new THREE.Vector3(0, -1, 0);

    forward.applyQuaternion(camera.quaternion);
    right.applyQuaternion(camera.quaternion);
    down.applyQuaternion(camera.quaternion);

    gunPosition.add(forward.multiplyScalar(0.5));
    gunPosition.add(right.multiplyScalar(0.3));
    gunPosition.add(down.multiplyScalar(0.2 + swayY));

    // Handle VISUAL recoil animation (doesn't affect shooting)
    let recoilOffset = new THREE.Vector3();
    let recoilRotation = { x: 0, y: 0, z: 0 };

    if (visualRecoil) {
      recoilTime.current += delta;
      const recoilDuration = 0.08; // Very quick visual recoil
      const recoilProgress = Math.min(recoilTime.current / recoilDuration, 1);
      const easedProgress = 1 - Math.pow(1 - recoilProgress, 3);

      const maxBackwardRecoil = 0.1;
      const maxUpwardRecoil = 0.05;
      const maxRotationRecoil = -0.2;

      const backwardRecoil = Math.sin(easedProgress * Math.PI) * maxBackwardRecoil;
      const upwardRecoil = Math.sin(easedProgress * Math.PI) * maxUpwardRecoil;
      const rotationRecoil = Math.sin(easedProgress * Math.PI) * maxRotationRecoil;

      recoilOffset.add(forward.clone().multiplyScalar(-backwardRecoil));
      recoilOffset.add(down.clone().multiplyScalar(-upwardRecoil));

      recoilRotation.x = -rotationRecoil;
      recoilRotation.z = (Math.random() - 0.5) * 0.05;
    }

    // Apply final position with recoil
    gunPosition.add(recoilOffset);
    gunRef.current.position.copy(gunPosition);

    // Apply rotation
    gunRef.current.quaternion.copy(camera.quaternion);
    gunRef.current.rotateX(0.1 + recoilRotation.x);
    gunRef.current.rotateY(Math.PI);
    gunRef.current.rotateZ(recoilRotation.z);
  });

  if (!isVisible) return null;

  return (
    <group ref={gunRef}>
      <pointLight position={[0.3, 0.2, 0.4]} intensity={1.5} distance={3} decay={1} color='#ffffff' />
      <pointLight position={[-0.2, -0.1, 0.3]} intensity={1.0} distance={2} decay={2} color='#fff8dc' />
      <GunModel scale={[1, 1, 1]} />
    </group>
  );
}

export default Gun;
```

`/home/suhas/Desktop/waitlist/src/components/game/Entity.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { Vector3 } from "three";
import * as THREE from "three";

function Entity({ playerPosition, onCatch, onDistanceUpdate }) {
  const entityRef = useRef();
  const entitySpeed = 2.5; // Slightly slower than player for tension
  const catchDistance = 1.2; // Distance at which entity catches player

  useEffect(() => {
    // Load entity texture
    const textureLoader = new THREE.TextureLoader();
    const entityTexture = textureLoader.load("/good.png");

    if (entityRef.current) {
      // Apply texture to entity material
      entityRef.current.material.map = entityTexture;
      entityRef.current.material.transparent = true;
      entityRef.current.material.needsUpdate = true;
      // Mark this as an entity for shooting detection
      entityRef.current.userData = { isEntity: true };
    }
  }, []);

  useFrame((state, delta) => {
    if (!entityRef.current || !playerPosition) return;

    const entityPosition = entityRef.current.position;

    // Calculate direction to player
    const direction = new Vector3().subVectors(playerPosition, entityPosition).normalize();

    // Move entity towards player
    const movement = direction.multiplyScalar(entitySpeed * delta);
    entityRef.current.position.add(movement);

    // Make entity always face the player
    entityRef.current.lookAt(playerPosition);

    // Calculate distance to player and update audio
    const distanceToPlayer = entityPosition.distanceTo(playerPosition);
    if (onDistanceUpdate) {
      onDistanceUpdate(distanceToPlayer);
    }

    // Check if entity caught the player
    if (distanceToPlayer < catchDistance) {
      onCatch();
    }
  });

  return (
    <mesh ref={entityRef} position={[10, 1.5, 10]}>
      <planeGeometry args={[3, 2]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default Entity;

```

`/home/suhas/Desktop/waitlist/src/components/game/AudioManager.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";

function AudioManager({ entityDistance, gameOver, onAudioStop }) {
  const audioRef = useRef(null);
  const breathRef = useRef(null);
  const deathSoundRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [hasInteracted, setHasInteracted] = useState(false);

  useEffect(() => {
    // Create background music audio element
    const audio = new Audio("/bgmusic.mp3");
    audio.loop = true;
    audio.volume = 0.001; // Start very quiet
    audioRef.current = audio;

    // Create breathing sound audio element
    const breathAudio = new Audio("/breath.mp3");
    breathAudio.loop = true;
    breathAudio.volume = 0; // Start at 0 for fade in
    breathRef.current = breathAudio;

    // Create death sound audio element
    const deathAudio = new Audio("/ded.mp3");
    deathAudio.volume = 1.0; // Full volume for death sound
    deathSoundRef.current = deathAudio;

    // Try to play background music immediately (will fail without user interaction)
    const tryAutoPlay = async () => {
      try {
        await audio.play();
        setIsPlaying(true);
      } catch (error) {
        console.log("Autoplay blocked, waiting for user interaction");
      }
    };

    tryAutoPlay();

    // Start breathing sound after 3 seconds with fade in
    const breathTimeout = setTimeout(() => {
      const startBreathingSound = async () => {
        try {
          await breathAudio.play();

          // Fade in the breathing sound over 2 seconds
          const fadeInDuration = 2000; // 2 seconds
          const targetVolume = 0.9; // Reduced volume for breathing
          const fadeSteps = 60; // Number of steps for smooth fade
          const stepTime = fadeInDuration / fadeSteps;
          const volumeStep = targetVolume / fadeSteps;

          let currentStep = 0;
          const fadeInterval = setInterval(() => {
            currentStep++;
            const newVolume = Math.min(volumeStep * currentStep, targetVolume);
            breathAudio.volume = newVolume;

            if (currentStep >= fadeSteps) {
              clearInterval(fadeInterval);
            }
          }, stepTime);
        } catch (error) {
          console.log("Failed to play breathing sound:", error);
        }
      };

      startBreathingSound();
    }, 3000); // 3 seconds delay

    // Listen for any user interaction to enable audio
    const handleInteraction = async () => {
      if (!hasInteracted) {
        setHasInteracted(true);
        try {
          await audio.play();
          setIsPlaying(true);
        } catch (error) {
          console.log("Failed to play audio:", error);
        }
      }
    };

    // Add event listeners for user interaction
    document.addEventListener("click", handleInteraction);
    document.addEventListener("keydown", handleInteraction);
    document.addEventListener("touchstart", handleInteraction);

    return () => {
      clearTimeout(breathTimeout);
      document.removeEventListener("click", handleInteraction);
      document.removeEventListener("keydown", handleInteraction);
      document.removeEventListener("touchstart", handleInteraction);
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
      if (breathRef.current) {
        if (breathRef.current.stopTimeout) {
          clearTimeout(breathRef.current.stopTimeout);
        }
        breathRef.current.pause();
        breathRef.current = null;
      }
      if (deathSoundRef.current) {
        if (deathSoundRef.current.timeout) {
          clearTimeout(deathSoundRef.current.timeout);
        }
        if (deathSoundRef.current.breathTimeout) {
          clearTimeout(deathSoundRef.current.breathTimeout);
        }
        if (deathSoundRef.current.allStopTimeout) {
          clearTimeout(deathSoundRef.current.allStopTimeout);
        }
        deathSoundRef.current.pause();
        deathSoundRef.current = null;
      }
    };
  }, [hasInteracted]);

// Handle game over - stop all audio and play death sound sequence
useEffect(() => {
  if (gameOver) {
    // Stop all existing audio immediately
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      setIsPlaying(false);
    }
    if (breathRef.current) {
      breathRef.current.pause();
      breathRef.current.currentTime = 0;
    }

    // Create a NEW death sound instance to avoid interference
    const deathAudio = new Audio("/ded.mp3");
    deathAudio.volume = 1.0;
    deathAudio.currentTime = 0;

    const playDeathSound = async () => {
      try {
        await deathAudio.play();
        console.log("Death sound started playing");
      } catch (error) {
        console.log("Failed to play death sound:", error);
      }
    };

    playDeathSound();

    // Stop death sound after 3 seconds
    const deathSoundTimeout = setTimeout(() => {
      deathAudio.pause();
      deathAudio.currentTime = 0;
      console.log("Death sound stopped after 3 seconds");
    }, 3000);

    // Start breathing sound after 2 seconds
    const breathStartTimeout = setTimeout(() => {
      if (breathRef.current) {
        breathRef.current.currentTime = 0;
        breathRef.current.volume = 0.9;

        const playBreathSound = async () => {
          try {
            await breathRef.current.play();
            console.log("Breath sound started playing");
          } catch (error) {
            console.log("Failed to play breath sound:", error);
          }
        };

        playBreathSound();
      }
    }, 2000);

    // Stop ALL audio after 6 seconds
    const allAudioStopTimeout = setTimeout(() => {
      console.log("Stopping all audio after 6 seconds");
      deathAudio.pause();
      deathAudio.currentTime = 0;
      
      if (breathRef.current) {
        breathRef.current.pause();
        breathRef.current.currentTime = 0;
      }
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
      console.log("All audio stopped - ready for join text");
    }, 6000);

    // Store cleanup function
    return () => {
      clearTimeout(deathSoundTimeout);
      clearTimeout(breathStartTimeout);
      clearTimeout(allAudioStopTimeout);
      deathAudio.pause();
    };
  }
}, [gameOver, onAudioStop]);

// Update audio volume based on entity distance (only if not game over)
useEffect(() => {
  if (!audioRef.current || !isPlaying || gameOver) return;

  // Calculate volume based on entity distance
  const maxDistance = 8;
  const minDistance = 2;
  const minVolume = 0.001;
  const maxVolume = 0.8;

  let volume = minVolume;

  if (entityDistance !== null) {
    if (entityDistance <= minDistance) {
      volume = maxVolume;
    } else if (entityDistance >= maxDistance) {
      volume = minVolume;
    } else {
      const normalizedDistance = (entityDistance - minDistance) / (maxDistance - minDistance);
      volume = maxVolume - normalizedDistance * (maxVolume - minVolume);
    }
  }

  // Smooth volume transition
  const currentVolume = audioRef.current.volume;
  const volumeDiff = volume - currentVolume;
  const smoothingFactor = 0.1;

  audioRef.current.volume = currentVolume + volumeDiff * smoothingFactor;
}, [entityDistance, isPlaying, gameOver]);

  // Audio manager runs silently with no UI
  return null;
}

export default AudioManager;

```

`/home/suhas/Desktop/waitlist/src/components/game/FirstPersonControls.jsx`:

```jsx
import React, { useRef, useEffect } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { Vector3 } from "three";
import * as THREE from "three";
import { isMobile } from "../../utils/device";

function FirstPersonControls({ onPositionUpdate, gameOver, mobileMovement }) {
  const { camera, scene } = useThree();
  const moveSpeed = 5;
  const playerRadius = 0.3; // Collision radius around player
  const baseHeight = 1.6; // Base camera height (eye level)
  const bobAmplitude = 0.08; // How much the camera bobs up and down
  const bobFrequency = 8; // How fast the bobbing occurs
  const bobTimeRef = useRef(0); // Track time for bobbing animation
  const isMovingRef = useRef(false); // Track if player is moving

  const keys = useRef({
    forward: false,
    backward: false,
    left: false,
    right: false,
  });

  // Handle keyboard input for desktop
  useEffect(() => {
    if (isMobile()) return; // Skip keyboard controls on mobile

    const handleKeyDown = event => {
      if (gameOver) return; // Disable movement when game is over

      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          keys.current.forward = true;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.current.backward = true;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.current.left = true;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.current.right = true;
          break;
      }
    };

    const handleKeyUp = event => {
      if (gameOver) return; // Disable movement when game is over

      switch (event.code) {
        case "KeyW":
        case "ArrowUp":
          keys.current.forward = false;
          break;
        case "KeyS":
        case "ArrowDown":
          keys.current.backward = false;
          break;
        case "KeyA":
        case "ArrowLeft":
          keys.current.left = false;
          break;
        case "KeyD":
        case "ArrowRight":
          keys.current.right = false;
          break;
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    };
  }, [gameOver]);

  // Handle mobile movement
  useEffect(() => {
    if (!isMobile() || !mobileMovement) return;

    // Convert joystick input to movement keys (more sensitive)
    keys.current.forward = mobileMovement.y > 0.1;
    keys.current.backward = mobileMovement.y < -0.1;
    keys.current.left = mobileMovement.x < -0.1;
    keys.current.right = mobileMovement.x > 0.1;
  }, [mobileMovement]);

  // Check for collisions using raycasting
  const checkCollision = newPosition => {
    const raycaster = new THREE.Raycaster();
    const directions = [
      new Vector3(1, 0, 0), // right
      new Vector3(-1, 0, 0), // left
      new Vector3(0, 0, 1), // forward
      new Vector3(0, 0, -1), // backward
      new Vector3(0.707, 0, 0.707), // diagonal
      new Vector3(-0.707, 0, 0.707), // diagonal
      new Vector3(0.707, 0, -0.707), // diagonal
      new Vector3(-0.707, 0, -0.707), // diagonal
    ];

    // Check collision in multiple directions around the player
    for (const direction of directions) {
      raycaster.set(newPosition, direction);
      const intersects = raycaster.intersectObjects(scene.children, true);

      // Filter out non-solid objects (lights, cameras, etc.)
      const solidIntersects = intersects.filter(intersect => {
        const object = intersect.object;
        // Check if object has geometry and is likely a wall/floor
        return object.geometry && object.material && !object.isLight && !object.isCamera && object.visible;
      });

      if (solidIntersects.length > 0 && solidIntersects[0].distance < playerRadius) {
        return true; // Collision detected
      }
    }
    return false; // No collision
  };

  // Update camera position based on input with collision detection and running animation
  useFrame((state, delta) => {
    if (gameOver) return; // Stop movement when game is over

    const velocity = new Vector3();
    const direction = new Vector3();

    camera.getWorldDirection(direction);
    direction.y = 0; // Keep movement horizontal
    direction.normalize();

    const right = new Vector3();
    right.crossVectors(direction, camera.up).normalize();

    if (keys.current.forward) velocity.add(direction);
    if (keys.current.backward) velocity.sub(direction);
    if (keys.current.right) velocity.add(right);
    if (keys.current.left) velocity.sub(right);

    // Check if player is moving
    const isMoving = velocity.length() > 0;
    isMovingRef.current = isMoving;

    if (isMoving) {
      velocity.normalize();
      velocity.multiplyScalar(moveSpeed * delta);

      // Calculate new position
      const newPosition = camera.position.clone().add(velocity);

      // Check for collision before moving
      if (!checkCollision(newPosition)) {
        camera.position.copy(newPosition);
      } else {
        // Try moving in individual axes if diagonal movement is blocked
        const xMovement = new Vector3(velocity.x, 0, 0);
        const zMovement = new Vector3(0, 0, velocity.z);

        const xPosition = camera.position.clone().add(xMovement);
        const zPosition = camera.position.clone().add(zMovement);

        if (!checkCollision(xPosition)) {
          camera.position.add(xMovement);
        } else if (!checkCollision(zPosition)) {
          camera.position.add(zMovement);
        }
        // If both individual axes are blocked, don't move
      }
    }

    // Handle running animation (head bob)
    if (isMovingRef.current) {
      // Increment bob time when moving
      bobTimeRef.current += delta * bobFrequency;

      // Calculate bobbing offset using sine wave
      const bobOffset = Math.sin(bobTimeRef.current) * bobAmplitude;

      // Apply bobbing to camera Y position
      camera.position.y = baseHeight + bobOffset;
    } else {
      // When not moving, gradually return to base height
      const currentHeight = camera.position.y;
      const heightDiff = baseHeight - currentHeight;

      // Smooth interpolation back to base height
      if (Math.abs(heightDiff) > 0.001) {
        camera.position.y += heightDiff * delta * 5; // Smooth return
      } else {
        camera.position.y = baseHeight;
      }

      // Reset bob time when not moving
      bobTimeRef.current = 0;
    }

    // Update player position for entity tracking
    if (onPositionUpdate) {
      onPositionUpdate(camera.position.clone());
    }
  });

  return null;
}

export default FirstPersonControls;
```

`/home/suhas/Desktop/waitlist/src/components/game/BloodEffect.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";
import * as THREE from "three";

function BloodEffect({ position, onComplete }) {
  const bloodRef = useRef();
  const [opacity, setOpacity] = useState(1);

  useEffect(() => {
    // Load blood texture
    const textureLoader = new THREE.TextureLoader();
    const bloodTexture = textureLoader.load("/blood.png");

    if (bloodRef.current) {
      bloodRef.current.material.map = bloodTexture;
      bloodRef.current.material.transparent = true;
      bloodRef.current.material.needsUpdate = true;
    }

    // Fade out blood effect over 3 seconds
    const fadeInterval = setInterval(() => {
      setOpacity(prev => {
        const newOpacity = prev - 0.02;
        if (newOpacity <= 0) {
          clearInterval(fadeInterval);
          if (onComplete) onComplete();
          return 0;
        }
        return newOpacity;
      });
    }, 50);

    return () => clearInterval(fadeInterval);
  }, [onComplete]);

  useEffect(() => {
    if (bloodRef.current) {
      bloodRef.current.material.opacity = opacity;
    }
  }, [opacity]);

  return (
    <mesh ref={bloodRef} position={position}>
      <planeGeometry args={[0.3, 0.3]} />
      <meshBasicMaterial side={THREE.DoubleSide} />
    </mesh>
  );
}

export default BloodEffect;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/MobileShootButton.jsx`:

```jsx
import React, { useState, useEffect } from "react";
import gunImage from "/shott.png";

function MobileShootButton({ onShoot, isVisible }) {
  const [isPressed, setIsPressed] = useState(false);
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth <= 768);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  const handleStart = e => {
    e.preventDefault();
    e.stopPropagation();

    console.log("📱 Mobile shoot button pressed");
    setIsPressed(true);

    if (onShoot) {
      onShoot();
    } else {
      console.log("❌ No onShoot function");
    }
  };

  const handleEnd = e => {
    e.preventDefault();
    e.stopPropagation();
    setIsPressed(false);
    console.log("📱 Mobile shoot button released");
  };

  if (!isVisible) return null;

  // Responsive sizes
  const size = isMobile ? 60 : 90;
  const imageSize = isMobile ? "60%" : "70%";

  return (
    <div
      style={{
        position: "fixed",
        bottom: isMobile ? "20px" : "40px",
        right: isMobile ? "20px" : "40px",
        width: `${size}px`,
        height: `${size}px`,
        borderRadius: "50%",
        backgroundColor: isPressed ? "#d8ca05ff" : "#ddd",
        border: "3px solid #fff",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
        touchAction: "none",
        userSelect: "none",
        transform: isPressed ? "scale(0.9)" : "scale(1)",
        transition: "all 0.05s ease",
        boxShadow: isPressed
          ? "0 0 16px rgba(255, 215, 0, 0.8)" // yellow glow
          : "0 4px 12px rgba(0,0,0,0.3)",
        cursor: "pointer",
      }}
      onTouchStart={handleStart}
      onTouchEnd={handleEnd}
      onTouchCancel={handleEnd}
      onMouseDown={handleStart}
      onMouseUp={handleEnd}
      onMouseLeave={handleEnd}
    >
      <img
        src={gunImage}
        alt='Shoot'
        style={{
          width: imageSize,
          height: imageSize,
          objectFit: "contain",
          pointerEvents: "none",
          filter: "brightness(0) invert(1)",
          rotate: "20deg",
        }}
      />
    </div>
  );
}

export default MobileShootButton;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/VirtualJoystick.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";

function VirtualJoystick({ onJoystickMove, isVisible }) {
  const [isDragging, setIsDragging] = useState(false);
  const [joystickPosition, setJoystickPosition] = useState({ x: 0, y: 0 });
  const [joystickVisible, setJoystickVisible] = useState(false);
  const [joystickCenter, setJoystickCenter] = useState({ x: 80, y: window.innerHeight - 80 });
  const joystickRef = useRef(null);
  const knobRef = useRef(null);
  const activeTouch = useRef(null);

  const maxDistance = 50;
  const deadZone = 0.15;

  const handleStart = e => {
    const touch = e.touches ? e.touches[0] : e;
    const touchX = touch.clientX;
    const touchY = touch.clientY;

    // Only activate if touch is on left side of screen AND no active joystick touch
    if (touchX > window.innerWidth / 2 || activeTouch.current !== null) return;

    e.preventDefault();
    e.stopPropagation(); // Prevent event bubbling

    setJoystickCenter({ x: touchX, y: touchY });
    setJoystickVisible(true);
    setIsDragging(true);
    activeTouch.current = e.touches ? e.touches[0].identifier : "mouse";
  };

  const handleMove = e => {
    if (!isDragging || activeTouch.current === null) return;

    // Find our specific touch
    const touch = e.touches ? Array.from(e.touches).find(t => t.identifier === activeTouch.current) : e;

    if (!touch) return;

    e.preventDefault();
    e.stopPropagation();

    const deltaX = touch.clientX - joystickCenter.x;
    const deltaY = touch.clientY - joystickCenter.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

    let normalizedX = deltaX / maxDistance;
    let normalizedY = deltaY / maxDistance;

    if (distance > maxDistance) {
      normalizedX = deltaX / distance;
      normalizedY = deltaY / distance;
    }

    const normalizedDistance = Math.min(distance / maxDistance, 1);
    if (normalizedDistance < deadZone) {
      normalizedX = 0;
      normalizedY = 0;
    } else {
      const scaledDistance = (normalizedDistance - deadZone) / (1 - deadZone);
      normalizedX *= scaledDistance;
      normalizedY *= scaledDistance;
    }

    setJoystickPosition({
      x: normalizedX * maxDistance,
      y: normalizedY * maxDistance,
    });

    if (onJoystickMove) {
      onJoystickMove({
        x: normalizedX,
        y: -normalizedY,
      });
    }
  };

  const handleEnd = e => {
    // Check if our specific touch ended
    if (e.touches && activeTouch.current !== null) {
      const stillActive = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
      if (stillActive) return; // Our touch is still active
    }

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(false);
    setJoystickVisible(false);
    setJoystickPosition({ x: 0, y: 0 });
    activeTouch.current = null;

    if (onJoystickMove) {
      onJoystickMove({ x: 0, y: 0 });
    }
  };

  useEffect(() => {
    if (!isDragging) return;

    // Add move and end listeners only when dragging
    const moveOptions = { passive: false };
    const endOptions = { passive: false };

    document.addEventListener("touchmove", handleMove, moveOptions);
    document.addEventListener("touchend", handleEnd, endOptions);
    document.addEventListener("touchcancel", handleEnd, endOptions);
    document.addEventListener("mousemove", handleMove, moveOptions);
    document.addEventListener("mouseup", handleEnd, endOptions);

    return () => {
      document.removeEventListener("touchmove", handleMove);
      document.removeEventListener("touchend", handleEnd);
      document.removeEventListener("touchcancel", handleEnd);
      document.removeEventListener("mousemove", handleMove);
      document.removeEventListener("mouseup", handleEnd);
    };
  }, [isDragging, joystickCenter, activeTouch.current]);

  useEffect(() => {
    // Listen for touch starts only on left side
    const handleTouchStart = e => {
      if (!isVisible) return;

      const touch = e.touches[0];
      if (touch.clientX <= window.innerWidth / 2) {
        handleStart(e);
      }
    };

    const handleMouseDown = e => {
      if (!isVisible) return;

      if (e.clientX <= window.innerWidth / 2) {
        handleStart(e);
      }
    };

    // Use capture phase to get events first
    document.addEventListener("touchstart", handleTouchStart, { passive: false, capture: true });
    document.addEventListener("mousedown", handleMouseDown, { passive: false, capture: true });

    return () => {
      document.removeEventListener("touchstart", handleTouchStart, { capture: true });
      document.removeEventListener("mousedown", handleMouseDown, { capture: true });
    };
  }, [isVisible]);

  if (!isVisible || !joystickVisible) return null;

  return (
    <div
      ref={joystickRef}
      style={{
        position: "fixed",
        left: joystickCenter.x - maxDistance - 10,
        top: joystickCenter.y - maxDistance - 10,
        width: (maxDistance + 10) * 2,
        height: (maxDistance + 10) * 2,
        borderRadius: "50%",
        backgroundColor: "rgba(255, 255, 255, 0.1)",
        border: "2px solid rgba(255, 255, 255, 0.3)",
        zIndex: 1000,
        pointerEvents: "none",
        userSelect: "none",
      }}
    >
      <div
        ref={knobRef}
        style={{
          position: "absolute",
          width: "30px",
          height: "30px",
          borderRadius: "50%",
          backgroundColor: "rgba(255, 255, 255, 0.9)",
          border: "2px solid rgba(255, 255, 255, 1)",
          left: "50%",
          top: "50%",
          transform: `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`,
          pointerEvents: "none",
          boxShadow: "0 2px 8px rgba(0,0,0,0.3)",
        }}
      />
    </div>
  );
}

export default VirtualJoystick;

```

`/home/suhas/Desktop/waitlist/src/components/mobile/MobileTouchControls.jsx`:

```jsx
// src/components/mobile/MobileTouchControls.jsx
import React, { useState, useRef, useEffect } from "react";
import { useThree } from "@react-three/fiber";
import * as THREE from "three";
import { isMobile } from "../../utils/device";

function MobileTouchControls({ gameOver }) {
  const { camera } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const lastTouch = useRef({ x: 0, y: 0 });
  const sensitivity = 0.007;
  const activeTouch = useRef(null);

  // Define shoot button area to exclude
  const shootButtonArea = {
    right: 40,
    bottom: 40,
    width: 100,
    height: 100,
  };

  // Check if touch is in shoot button area
  const isTouchInShootButton = (touchX, touchY) => {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    const buttonLeft = screenWidth - shootButtonArea.right - shootButtonArea.width;
    const buttonTop = screenHeight - shootButtonArea.bottom - shootButtonArea.height;
    const buttonRight = screenWidth - shootButtonArea.right;
    const buttonBottom = screenHeight - shootButtonArea.bottom;

    return touchX >= buttonLeft && touchX <= buttonRight && touchY >= buttonTop && touchY <= buttonBottom;
  };

  const handleTouchStart = e => {
    if (gameOver) return;

    // Find a touch on the right side that we're not already tracking
    let rightSideTouch = null;
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];

      // Check if touch is on right side AND not in shoot button area
      if (
        touch.clientX > window.innerWidth / 2 &&
        !isTouchInShootButton(touch.clientX, touch.clientY) &&
        (activeTouch.current === null || activeTouch.current !== touch.identifier)
      ) {
        rightSideTouch = touch;
        break;
      }
    }

    if (!rightSideTouch || activeTouch.current !== null) return;

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(true);
    activeTouch.current = rightSideTouch.identifier;
    lastTouch.current = {
      x: rightSideTouch.clientX,
      y: rightSideTouch.clientY,
    };
  };

  const handleTouchMove = e => {
    if (!isDragging || activeTouch.current === null || gameOver) return;

    // Find our specific touch
    const touch = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
    if (!touch) return;

    e.preventDefault();
    e.stopPropagation();

    const deltaX = touch.clientX - lastTouch.current.x;
    const deltaY = touch.clientY - lastTouch.current.y;

    // Store current rotations
    const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, "YXZ");

    // Apply rotations
    euler.y -= deltaX * sensitivity;
    euler.x -= deltaY * sensitivity;
    euler.z = 0; // Prevent tilting

    // Clamp vertical rotation
    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

    // Apply back to camera
    camera.quaternion.setFromEuler(euler);

    lastTouch.current = {
      x: touch.clientX,
      y: touch.clientY,
    };
  };

  const handleTouchEnd = e => {
    if (activeTouch.current === null) return;

    // Check if our specific touch ended
    const touchStillActive = Array.from(e.touches).find(t => t.identifier === activeTouch.current);
    if (touchStillActive) return; // Our touch is still active

    e.preventDefault();
    e.stopPropagation();

    setIsDragging(false);
    activeTouch.current = null;
  };

  useEffect(() => {
    if (!isMobile() || gameOver) return;

    // Use capture phase to handle events before they bubble
    const options = { passive: false, capture: true };

    const startHandler = e => {
      // Only handle touches on right side that are NOT in shoot button area
      const hasValidRightSideTouch = Array.from(e.touches).some(
        touch => touch.clientX > window.innerWidth / 2 && !isTouchInShootButton(touch.clientX, touch.clientY)
      );

      if (hasValidRightSideTouch) {
        handleTouchStart(e);
      }
    };

    const moveHandler = e => {
      if (isDragging) {
        handleTouchMove(e);
      }
    };

    const endHandler = e => {
      if (isDragging) {
        handleTouchEnd(e);
      }
    };

    document.addEventListener("touchstart", startHandler, options);
    document.addEventListener("touchmove", moveHandler, options);
    document.addEventListener("touchend", endHandler, options);
    document.addEventListener("touchcancel", endHandler, options);

    return () => {
      document.removeEventListener("touchstart", startHandler, { capture: true });
      document.removeEventListener("touchmove", moveHandler, { capture: true });
      document.removeEventListener("touchend", endHandler, { capture: true });
      document.removeEventListener("touchcancel", endHandler, { capture: true });
    };
  }, [isDragging, gameOver, activeTouch.current]);

  return null;
}

export default MobileTouchControls;

```

`/home/suhas/Desktop/waitlist/src/components/ui/Join.jsx`:

```jsx
import React, { useRef, useEffect, useState } from "react";
import { supabase } from '../../lib/supabase'; 

function Join() {
  const [username, setUsername] = useState("");
  const [showLinks, setShowLinks] = useState(false);
  const [inputDisabled, setInputDisabled] = useState(false);
  const [showCursor, setShowCursor] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitStatus, setSubmitStatus] = useState("");
  const inputRef = useRef(null);

  useEffect(() => {
    if (inputRef.current && !inputDisabled) {
      inputRef.current.focus();
    }
  }, [inputDisabled]);

// Function to send data to Supabase
const submitToSupabase = async username => {
  
  
  // Try a simple test
  const { data, error } = await supabase.from('waitlist').select('count');
  console.log("Test query result:", { data, error });
  try {
    // Format current time in user's local timezone
    const currentTime = new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
      timeZoneName: 'short'
    });
    
    // Get total count for sl_no
    const { count } = await supabase
      .from('waitlist')
      .select('*', { count: 'exact' });

    // Insert data with sequential sl_no
    const { data, error } = await supabase
      .from('waitlist')
      .insert({

        username: String(username),
        joined_at: new Date().toISOString()

      })
      .select();

    if (error) {
      console.error("Error saving data to Supabase:", error);
      setSubmitStatus("❌ Error adding to waitlist. Please try again.");
      return false;
    }

    console.log("Data saved successfully to Supabase:", data);
    setSubmitStatus("✅ Successfully added to waitlist!");
    return true;

  } catch (error) {
    console.error("Error during Supabase operation:", error);
    setSubmitStatus("❌ Network error. Please check your connection.");
    return false;
  }
};

 const handleKeyPress = async e => {
  if (e.key === "Enter" && username.trim() && !isSubmitting) {
    setIsSubmitting(true);
    setInputDisabled(true);
    setShowCursor(false);
    setSubmitStatus("⏳ Adding to waitlist...");

    // Submit to Supabase (change this line)
    const success = await submitToSupabase(username.trim());

    if (success) {
      // Show links after successful submission
      setTimeout(() => {
        setShowLinks(true);
      }, 1000);
    } else {
      // Re-enable input on error
      setInputDisabled(false);
      setShowCursor(true);
    }

    setIsSubmitting(false);
  }
};

  const handleFocus = () => {
    setShowCursor(false);
  };

  const handleBlur = () => {
    if (!inputDisabled) {
      setShowCursor(true);
    }
  };

  const handleClick = () => {
    if (!inputDisabled && inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div
      className='terminal'
      onClick={handleClick}
      style={{
        width: "100%",
        height: "100vh",
        padding: "15px", // Reduced padding
        backgroundColor: "#000",
        color: "#00ff00",
        fontFamily: "'Jersey 15', monospace",
        fontSize: "18px", // Reduced from 30px
        lineHeight: "1.3", // Tighter line height
        overflow: "hidden",
      }}
    >
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Jersey+15&display=swap');

          body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }

          .terminal {
            overflow-y: auto;
          }

          .cursor {
            display: inline-block;
            width: 6px; /* Smaller cursor */
            height: 12px; /* Smaller cursor */
            background-color: #00ff00;
            animation: blink 1s infinite;
          }

          @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
          }

          .terminal-input {
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Jersey 15', monospace;
            font-size: 18px; /* Reduced from 30px */
            outline: none;
            flex: 1;
          }

          .links a {
            color: #00ff00;
            text-decoration: underline;
          }

          .links a:hover {
            color: #00ffff;
          }

          .status-message {
            font-size: 14px; /* Reduced from 20px */
            margin-top: 8px;
            opacity: 0.8;
          }

          .success-message {
            color: #00ff00;
          }

          .error-message {
            color: #ff6b6b;
          }

          .loading-message {
            color: #ffff00;
          }

          /* Mobile responsive adjustments */
          @media (max-width: 768px) {
            .terminal {
              font-size: 14px !important;
              padding: 10px !important;
            }
            
            .terminal-input {
              font-size: 14px !important;
            }
            
            .ascii-art {
              font-size: 8px !important;
              line-height: 1.1 !important;
            }
            
            .status-message {
              font-size: 12px !important;
            }
          }

          @media (max-width: 480px) {
            .terminal {
              font-size: 12px !important;
              padding: 8px !important;
            }
            
            .terminal-input {
              font-size: 12px !important;
            }
            
            .ascii-art {
              font-size: 6px !important;
              line-height: 1.0 !important;
            }
            
            .status-message {
              font-size: 10px !important;
            }
          }
        `}
      </style>

      {/* ASCII Art with smaller size */}
      <div 
        className="ascii-art"
        style={{ 
          marginBottom: "15px", // Reduced margin
          whiteSpace: "pre",
          fontSize: "10px", // Much smaller ASCII art
          lineHeight: "1.2",
          overflow: "hidden"
        }}
      >
        {`██████╗░██╗░░░░░░█████╗░░█████╗░██╗░░██╗██████╗░░█████╗░░█████╗░███╗░░░███╗░██████╗
██╔══██╗██║░░░░░██╔══██╗██╔══██╗██║░██╔╝██╔══██╗██╔══██╗██╔══██╗████╗░████║██╔════╝
██████╦╝██║░░░░░██║░░██║██║░░╚═╝█████═╝░██████╔╝██║░░██║██║░░██║██╔████╔██║╚█████╗░
██╔══██╗██║░░░░░██║░░██║██║░░██╗██╔═██╗░██╔══██╗██║░░██║██║░░██║██║╚██╔╝██║░╚═══██╗
██████╦╝███████╗╚█████╔╝╚█████╔╝██║░╚██╗██║░░██║╚█████╔╝╚█████╔╝██║░╚═╝░██║██████╔╝
╚═════╝░╚══════╝░╚════╝░░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░░╚════╝░╚═╝░░░░░╚═╝╚═════╝░`}
      </div>

      <div style={{ marginTop: "20px" }}> {/* Reduced margin */}
        <div style={{ fontSize: "16px", marginBottom: "8px" }}> {/* Smaller instruction text */}
          Enter your Discord Username to join the waitlist
        </div>
        <div style={{ display: "flex", alignItems: "center" }}>
          <span style={{ marginRight: "5px" }}>{">"}</span>
          <input
            ref={inputRef}
            type='text'
            value={username}
            onChange={e => setUsername(e.target.value)}
            onKeyPress={handleKeyPress}
            onFocus={handleFocus}
            onBlur={handleBlur}
            disabled={inputDisabled}
            className='terminal-input'
            autoComplete='off'
            placeholder={inputDisabled ? "" : "your_discord_username"}
          />
          {showCursor && <span className='cursor'></span>}
        </div>

        {/* Status Message */}
        {submitStatus && (
          <div
            className={`status-message ${
              submitStatus.includes("✅") ? "success-message" : submitStatus.includes("❌") ? "error-message" : "loading-message"
            }`}
          >
            {submitStatus}
          </div>
        )}

        {showLinks && (
          <div className='links' style={{ marginTop: "15px" }}> {/* Reduced margin */}
            <div style={{ marginBottom: "8px", fontSize: "16px" }}> {/* Smaller welcome text */}
              Welcome to the waitlist! Join our community:
            </div>
            <div style={{ fontSize: "14px", marginBottom: "5px" }}> {/* Smaller link text */}
              Twitter:{" "}
              <a href='https://x.com/_BlockRooms' target='_blank' rel='noopener noreferrer'>
                https://x.com/_BlockRooms
              </a>
            </div>
            <div style={{ fontSize: "14px", marginBottom: "8px" }}> {/* Smaller link text */}
              Discord:{" "}
              <a href='https://discord.com/invite/jcpgh3KS3z' target='_blank' rel='noopener noreferrer'>
                https://discord.com/invite/jcpgh3KS3z
              </a>
            </div>
            <div style={{ marginTop: "10px", fontSize: "12px", opacity: "0.7" }}> {/* Smaller footer text */}
              You'll receive updates via Discord. Keep an eye on your DMs!
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default Join;
```

`/home/suhas/Desktop/waitlist/src/components/ui/WarningDialog.jsx`:

```jsx
import React, { useEffect, useState } from "react";

function WarningDialog({ onAccept }) {
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [loadingText, setLoadingText] = useState("Loading assets...");
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Simplified loading - just simulate progress
    let progress = 0;
    const interval = setInterval(() => {
      progress += Math.random() * 15; // Random progress increments

      if (progress >= 100) {
        progress = 100;
        setLoadingProgress(100);
        setLoadingText("Ready to play!");
        setTimeout(() => {
          setIsLoaded(true);
          clearInterval(interval);
        }, 500);
      } else {
        setLoadingProgress(progress);
      }
    }, 200);

    // Fallback - force complete after 3 seconds
    const fallback = setTimeout(() => {
      setLoadingProgress(100);
      setLoadingText("Ready to play!");
      setIsLoaded(true);
      clearInterval(interval);
    }, 3000);

    return () => {
      clearInterval(interval);
      clearTimeout(fallback);
    };
  }, []);

  const handleClick = () => {
    if (isLoaded && onAccept) {
      onAccept();
    }
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        backgroundColor: "rgba(0, 0, 0, 0.85)",
        zIndex: 20000,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <div
        style={{
          width: "500px",
          height: "320px",
          backgroundColor: "#c0c0c0",
          border: "2px outset #c0c0c0",
          fontFamily: "MS Sans Serif, sans-serif",
          fontSize: "11px",
        }}
      >
        {/* Title Bar */}
        <div
          style={{
            height: "20px",
            background: "linear-gradient(90deg, #0000ff 0%, #008080 100%)",
            color: "white",
            display: "flex",
            alignItems: "center",
            padding: "2px 8px",
            fontSize: "14px",
            fontWeight: "bold",
          }}
        >
          <span>BlockRooms</span>
        </div>

        {/* Content Area */}
        <div
          style={{
            padding: "5px 20px 2px 20px",
            height: "300px",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            textAlign: "center",
          }}
        >
          <div
            style={{
              fontSize: "17px",
              marginBottom: "20px",
              lineHeight: "0.5",
            }}
          >
            This is just a waitlist site and not the actual gameplay.
          </div>

          {/* Loading Section */}
          <div style={{ width: "100%", marginBottom: "20px" }}>
            <div
              style={{
                fontSize: "12px",
                marginBottom: "10px",
                textAlign: "left",
              }}
            >
              {loadingText}
            </div>

            {/* Progress Bar */}
            <div
              style={{
                width: "100%",
                height: "20px",
                border: "2px inset #c0c0c0",
                backgroundColor: "#ffffff",
                position: "relative",
                overflow: "hidden",
              }}
            >
              <div
                style={{
                  height: "100%",
                  width: `${loadingProgress}%`,
                  background: "linear-gradient(90deg, #316AC5 0%, #52A6F5 50%, #316AC5 100%)",
                  transition: "width 0.3s ease",
                }}
              />
            </div>

            <div
              style={{
                fontSize: "11px",
                marginTop: "5px",
                textAlign: "right",
                color: "#666",
              }}
            >
              {Math.round(loadingProgress)}%
            </div>
          </div>

          {/* Tutorial Section - Only show when loaded */}
          {isLoaded && (
            <div
              style={{
                fontSize: "12px",
                lineHeight: "1.4",
                marginBottom: "20px",
                textAlign: "left",
                width: "100%",
                backgroundColor: "#f0f0f0",
                padding: "2px 20px 1px 5px",
                border: "1px inset #c0c0c0",
              }}
            >
              <div style={{ fontWeight: "bold", marginBottom: "2px", textAlign: "center" }}>
                🎮 Quick Tutorial
              </div>
              <div style={{ marginBottom: "5px" }}>
                <strong>Goal:</strong> Survive the entity hunting you
              </div>
              <div style={{ marginBottom: "5px" }}>
                <strong>Controls:</strong> WASD/Arrows to move, Mouse to look, Click to shoot
              </div>
              <div style={{ fontSize: "11px", color: "#666", fontStyle: "italic" }}>
                Entity spawns in 3 seconds. Music gets louder as it approaches!
              </div>
            </div>
          )}

          {/* OK Button */}
          <div style={{ display: "flex", justifyContent: "center" }}>
            <button
              onClick={handleClick}
              style={{
                width: "100px",
                height: "30px",
                backgroundColor: isLoaded ? "#c0c0c0" : "#d4d0c8",
                border: isLoaded ? "3px outset #c0c0c0" : "2px inset #d4d0c8",
                fontSize: "15px",
                cursor: isLoaded ? "pointer" : "not-allowed",
                fontFamily: "MS Sans Serif, sans-serif",
                color: isLoaded ? "#000000" : "#808080",
                opacity: isLoaded ? 1 : 0.6,
              }}
            >
              {isLoaded ? "Ok" : "Loading..."}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

export default WarningDialog;
```

`/home/suhas/Desktop/waitlist/src/components/ui/DeathScreen.jsx`:

```jsx
// src/components/ui/DeathScreen.jsx
import React, { useEffect, useState } from "react";

function DeathScreen({ onJoin }) {
  const [showTV, setShowTV] = useState(false);
  const [showJoinText, setShowJoinText] = useState(false);

  useEffect(() => {
    // Automatically unlock cursor when death screen appears
    if (document.pointerLockElement) {
      document.exitPointerLock();
    }

    // Show TV image after 3 seconds
    const tvTimeout = setTimeout(() => {
      setShowTV(true);
    }, 3000);

    // Show join text after 6 seconds
    const joinTextTimeout = setTimeout(() => {
      setShowJoinText(true);
    }, 6000);

    return () => {
      clearTimeout(tvTimeout);
      clearTimeout(joinTextTimeout);
    };
  }, []);

  const handleClick = () => {
    if (showJoinText && onJoin) {
      onJoin();
    }
  };

  return (
    <div
      onClick={handleClick}
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        backgroundColor: "black",
        zIndex: 10000,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        cursor: showJoinText ? "pointer" : "default",
        overflow: "hidden",
      }}
    >
      {showTV && (
        <div style={{ position: "relative", width: "100vw", height: "100vh" }}>
          <img
            src='/tv2.png'
            alt='TV'
            style={{
              width: "100vw",
              height: "100vh",
              objectFit: "cover",
              display: "block",
            }}
          />
          {showJoinText && (
            <div
              style={{
                position: "absolute",
                bottom: "10%",
                left: "50%",
                transform: "translateX(-50%)",
                color: "white",
                fontSize: "24px",
                fontFamily: "Arial, sans-serif",
                fontWeight: "bold",
                textAlign: "center",
                textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
                animation: "pulse 2s infinite",
                userSelect: "none",
                whiteSpace: "nowrap",
              }}
            >
              tap anywhere to join
            </div>
          )}
        </div>
      )}

      <style jsx>{`
        @keyframes pulse {
          0% {
            opacity: 1;
          }
          50% {
            opacity: 0.5;
          }
          100% {
            opacity: 1;
          }
        }
      `}</style>
    </div>
  );
}

export default DeathScreen;

```

`/home/suhas/Desktop/waitlist/src/index.jsx`:

```jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App"; // Keep this as ./App for now
import "./styles.css";

const root = createRoot(document.getElementById("root"));
root.render(<App />);

```

`/home/suhas/Desktop/waitlist/src/Gun1.jsx`:

```jsx
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/gun1.glb 
Author: DJMaesen (https://sketchfab.com/bumstrum)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/animated-pistol-bd896167e7ca44f19597d3afe6a8d83f
Title: animated pistol
*/

import React from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations } from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";

export function Model(props) {
  const group = React.useRef();
  const { scene, animations } = useGLTF("/gun1.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);
  const { actions } = useAnimations(animations, group);

  return (
    <group ref={group} {...props} dispose={null}>
      <group name='Sketchfab_Scene'>
        <group name='Sketchfab_model' rotation={[-Math.PI / 2, 0, 0]}>
          <group name='105d2810571c4501ba07ac55c5582245fbx' rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name='Object_2'>
              <group name='RootNode'>
                <group name='Root' position={[0, 16.327, -8.923]}>
                  <group name='Object_5'>
                    <group name='pistol' position={[0, -12.318, 25.913]}>
                      <group name='stopper' position={[1.26, 5.502, 5.615]}>
                        <mesh name='stopper_beretta_0' geometry={nodes.stopper_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='mag' position={[0, -0.379, 0.406]} rotation={[0.262, 0, 0]}>
                        <group name='shell' position={[0, 7.4, -0.455]} rotation={[-0.262, 0, 0]}>
                          <group name='bullet_2_2' position={[0, 0, 0.935]}>
                            <mesh name='bullet_2_2_beretta_0' geometry={nodes.bullet_2_2_beretta_0.geometry} material={materials.beretta} />
                          </group>
                          <mesh name='shell_beretta_0' geometry={nodes.shell_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <group name='shell_1_2' position={[0, 6.293, -0.158]} rotation={[-0.262, 0, 0]}>
                          <group name='bullet' position={[0, 0, 0.935]}>
                            <mesh name='bullet_beretta_0' geometry={nodes.bullet_beretta_0.geometry} material={materials.beretta} />
                          </group>
                          <mesh name='shell_1_2_beretta_0' geometry={nodes.shell_1_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <mesh name='mag_beretta_0' geometry={nodes.mag_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='hammer' position={[0, 5.573, -1.608]} rotation={[-1.242, 0, 0]}>
                        <mesh name='hammer_beretta_0' geometry={nodes.hammer_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='trigger' position={[0, 4.404, 6.033]}>
                        <mesh name='trigger_beretta_0' geometry={nodes.trigger_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='slide' position={[0, 7.341, 3.872]}>
                        <mesh name='slide_beretta_0' geometry={nodes.slide_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='base'>
                        <mesh name='base_beretta_0' geometry={nodes.base_beretta_0.geometry} material={materials.beretta} />
                      </group>
                      <group name='shell_1' position={[0, 7.849, 6.937]}>
                        <group name='bullet_2' position={[0, 0, 0.935]}>
                          <mesh name='bullet_2_beretta_0' geometry={nodes.bullet_2_beretta_0.geometry} material={materials.beretta} />
                        </group>
                        <mesh name='shell_1_beretta_0' geometry={nodes.shell_1_beretta_0.geometry} material={materials.beretta} />
                      </group>
                    </group>
                    <primitive object={nodes._rootJoint} />
                    <group name='Object_82' position={[0, 3.036, -1.334]} />
                    <skinnedMesh
                      name='Object_83'
                      geometry={nodes.Object_83.geometry}
                      material={materials.arms}
                      skeleton={nodes.Object_83.skeleton}
                    />
                  </group>
                </group>
                <group name='armsmesh' position={[0, 3.036, -1.334]} rotation={[-0.002, 0, -0.011]} />
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/gun1.glb");

```

`/home/suhas/Desktop/waitlist/src/styles.css`:

```css
/* Prevent mobile browser zoom and selection */
* {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* Prevent zoom on double tap */
body {
  touch-action: manipulation;
  -webkit-touch-callout: none;
  -webkit-text-size-adjust: none;
  -webkit-user-select: none;
  user-select: none;
}

/* Prevent iOS Safari bounce and zoom + Fullscreen support */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  height: 100dvh; 
  overflow: hidden;
  background: black;
  position: fixed; /* Prevent any scrolling */
}

/* Enhanced mobile support */
@media screen and (max-width: 768px) {
  html, body {
    height: 100vh;
    height: -webkit-fill-available; /* Safari mobile */
    height: 100dvh; /* Dynamic viewport height */
  }
  
  body {
    min-height: 100vh;
    min-height: -webkit-fill-available;
    min-height: 100dvh;
  }
}

/* Landscape orientation prompt for mobile */
@media screen and (orientation: portrait) and (max-width: 768px) {
  body::before {
    content: "🔄 Please rotate your device to landscape mode for the best experience";
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 20px;
    border-radius: 10px;
    z-index: 99999;
    text-align: center;
    font-family: Arial, sans-serif;
    font-size: 16px;
    max-width: 80%;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8);
    border: 2px solid #333;
  }
}

/* Prevent zoom on input focus (if any) */
input,
textarea,
select {
  font-size: 16px !important;
  -webkit-user-select: text;
  user-select: text;
  -webkit-appearance: none; /* Remove iOS styling */
  border-radius: 0; /* Remove iOS rounded corners */
}

/* Game canvas specific */
canvas {
  touch-action: none;
  -webkit-touch-callout: none;
  display: block;
  position: fixed !important; /* Force fixed positioning */
  top: 0 !important; 
  left: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  height: 100dvh !important; /* Dynamic viewport height */
  z-index: 1; /* Ensure canvas is behind UI elements */
}

/* Fullscreen mode optimizations */
:fullscreen {
  width: 100vw !important;
  height: 100vh !important;
}

:-webkit-full-screen {
  width: 100vw !important;
  height: 100vh !important;
}

:-moz-full-screen {
  width: 100vw !important;
  height: 100vh !important;
}

:-ms-fullscreen {
  width: 100vw !important;
  height: 100vh !important;
}

/* PWA and mobile app styles */
@media (display-mode: fullscreen) {
  body {
    background: black;
  }
}

@media (display-mode: standalone) {
  body {
    background: black;
  }
}

/* Safe area handling for devices with notches */
@supports (padding: max(0px)) {
  body {
    padding-left: max(0px, env(safe-area-inset-left));
    padding-right: max(0px, env(safe-area-inset-right));
    padding-top: max(0px, env(safe-area-inset-top));
    padding-bottom: max(0px, env(safe-area-inset-bottom));
  }
}

/* Mobile UI elements positioning */
@media screen and (max-width: 768px) {
  /* Ensure mobile controls are above canvas */
  div[style*="position: fixed"] {
    z-index: 1000 !important;
  }
  
  /* Mobile joystick and button positioning */
  div[style*="bottom:"] {
    bottom: max(40px, calc(40px + env(safe-area-inset-bottom))) !important;
  }
  
  div[style*="right:"] {
    right: max(40px, calc(40px + env(safe-area-inset-right))) !important;
  }
  
  div[style*="left:"] {
    left: max(40px, calc(40px + env(safe-area-inset-left))) !important;
  }
}

/* Hide scrollbars */
::-webkit-scrollbar {
  display: none;
}

html {
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}

/* Prevent text selection during gameplay */
.game-active {
  -webkit-user-select: none !important;
  -moz-user-select: none !important;
  -ms-user-select: none !important;
  user-select: none !important;
}

/* Loading and dialog positioning */
div[style*="position: fixed"][style*="z-index"] {
  width: 100vw !important;
  height: 100vh !important;
  height: 100dvh !important;
}
```